<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序之外的算法——动态规划]]></title>
    <url>%2F2020%2F03%2F02%2F%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A4%96%E7%9A%84%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[贪排序之外的算法——贪心算法]]></title>
    <url>%2F2020%2F03%2F02%2F%E8%B4%AA%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A4%96%E7%9A%84%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之JVM基础]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8BJVM%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之List、Map及其衍生子类]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8BList%E3%80%81Map%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E5%AD%90%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之烂大街的抽象类和接口]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E7%83%82%E5%A4%A7%E8%A1%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaEE之事务]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaEE%E4%B9%8B%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———从头学起计算机网络]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94%E4%BB%8E%E5%A4%B4%E5%AD%A6%E8%B5%B7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之迭代器]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之枚举]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之泛型]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———java Frame之Mybatis的二级缓存]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94java-Frame%E4%B9%8BMybatis%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———java Frame之Mybatis的动态SQL]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94java-Frame%E4%B9%8BMybatis%E7%9A%84%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———java Frame之spring自动装配]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94java-Frame%E4%B9%8Bspring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———java Frame之spring的bean]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94java-Frame%E4%B9%8Bspring%E7%9A%84bean%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———java Frame之烂大街的aop和ioc]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94java-Frame%E4%B9%8Bspring%E7%83%82%E5%A4%A7%E8%A1%97%E7%9A%84aop%E5%92%8Cioc%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaEE之JDBC]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaEE%E4%B9%8BJDBC%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaEE之服Servlet，Tomcat，Jetty，Netty]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaEE%E4%B9%8B%E6%9C%8DServlet%EF%BC%8CTomcat%EF%BC%8CJetty%EF%BC%8CNetty%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaEE之Cookie和Session]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaEE%E4%B9%8BCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaEE之servlet]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaEE%E4%B9%8Bservlet%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之异常和throw(s)]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%92%8Cthrow-s%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之Serializable序列化]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8BSerializable%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之垃圾回收]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之集合]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之比较器]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E6%AF%94%E8%BE%83%E5%99%A8%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之Vector]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8BVector%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之static]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8Bstatic%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之线程池]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之IO]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8BIO%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[书到用时方恨少———javaSE之线程]]></title>
    <url>%2F2020%2F03%2F02%2F%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[华为2016校园招聘上机笔试题-----OJ系统的坑]]></title>
    <url>%2F2020%2F03%2F01%2F%E5%8D%8E%E4%B8%BA2016%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AF%95%E9%A2%98-OJ%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[校招一共三道编程题。思路很容易想到，但是在面对细节实现时，终究还是感觉自己要更加努力。有一些小细节把我卡住了好久。另外最让我抓狂的，便是牛客网系统的输入问题，像第一题总是提示输入为空。而第二题，答案都是一摸一样，竟然还说我输出不一致。。。Qustion 1 : 最高分是多少1老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩.输入描述:123456输入包括多组测试数据。每组输入第一行是两个正整数N和M（0 &lt; N &lt;= 30000,0 &lt; M &lt; 5000）,分别代表学生的数目和操作的数目。学生ID编号从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为&apos;Q&apos;的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。输出描述:1对于每一次询问操作，在一行里面输出最高成绩.示例1输入1234567895 71 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 4 5U 2 9Q 1 5输出12345659Answer 1:123456789101112131415161718Scanner input = new Scanner(System.in);int N = input.nextInt();int M = input.nextInt();//为了使学号ID和个人成绩一一对应，不想要那种减一加一那种，所以数组大了一个。int[] score = new int[N + 1];int scoreInputIndex = 1;int operationInputIndex = 0;while(input.hasNextInt() &amp;&amp; scoreInputIndex &lt;= N)&#123; score[scoreInputIndex] = input.nextInt(); scoreInputIndex ++;&#125;while(input.hasNext())&#123; String C = input.next(); int num1 = input.nextInt(); int num2 = input.nextInt(); //进行更新查询操作&#125;当然这个代码在牛客网提交的时候，是显示输入为空的，但是本地运行是能够正确出结果的，头都要秃了，然而我还是找不到问题所在。知道在答案区看到了别人写的，然后结合我自己的，终于通过了所有测试用例：123456789101112131415161718Scanner input = new Scanner(System.in); while(input.hasNext())&#123; int N = input.nextInt(); int M = input.nextInt(); int[] score = new int[N + 1]; int scoreInputIndex = 1; int operationInputIndex = 0; for(int x = 1; input.hasNext() &amp;&amp; x &lt;= N; x ++)&#123; score[scoreInputIndex ++] = input.nextInt(); &#125; for(int x = 0; input.hasNext() &amp;&amp; x &lt; M; x ++)&#123; String C = input.next(); int num1 = input.nextInt(); int num2 = input.nextInt(); count(C,num1,num2,score); &#125; &#125;经过上网查证，我自己是这么理解的不知道对不对。。。首先，OJ或者牛客网这种网站，在测试程序时，是一次性放入许多组数据的，我们自己测试的时候是一组一组的放进去，而OJ似乎是一次性放入的。这就是导致，如果在OJ有大量数据输入，我们只能用1234Scanner input = new Scanner(System.in); while(input.hasNext()) 或者 for(int x = 0; input.hasNext(); x ++)这两种输入之一。但是那样的话，我的第一种方法也应该是可以的呀。后来又看到了一篇文章，说的是next()和nextLine()的差别1https://www.ihewro.com/archives/910/1234nextInt()、nextFloat()之类函数与next()特性一致。 next() 必须先进行有效输入（不包括结束符号的字符）才能结束输入（否则一直是等待输入的状态），然后再使用结束符号结束当前输入（回车、换行、TAB、空格的任一种） nextLine()：就没有上面约束了，能接收任何字符，结束符号只有回车一个，所以可以输入含有空格的字符串。而在OJ中，当有多组测试用例一同输入时，以EOF结束。1多组数据输入，不确定组数，以EOF结束。然而我还是不清楚，我的第一种输入和第二种输入，到底有什么差别。。。。。附第一题的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Arrays;import java.util.Scanner; public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while(input.hasNext())&#123; int N = input.nextInt(); int M = input.nextInt(); //为了使学号ID和个人成绩一一对应，不想要那种减一加一那种，所以数组大了一个。 int[] score = new int[N + 1]; int scoreInputIndex = 1; int operationInputIndex = 0; for(int x = 1; input.hasNext() &amp;&amp; x &lt;= N; x ++)&#123; score[scoreInputIndex ++] = input.nextInt(); &#125; for(int x = 0; input.hasNext() &amp;&amp; x &lt; M; x ++)&#123; String C = input.next(); int num1 = input.nextInt(); int num2 = input.nextInt(); count(C,num1,num2,score); &#125; &#125; &#125; static int[] count(String C,int num1,int num2,int[] score)&#123; int result = 0; switch (C) &#123; case "Q": result = max(score, num1, num2); System.out.println(result); break; case "U": score[num1] = num2; break; default: break; &#125; return score; &#125; static int max(int[] score,int start,int end)&#123; int result = 0; if(start &gt; end)&#123; int temp = start; start = end; end = temp; &#125; for(int x = start;x &lt;= end; x ++)&#123; if(result &lt; score[x])&#123; result = score[x]; &#125; &#125; return result; &#125;&#125;Qustion2: 简单错误记录12345开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 处理: 1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并) 2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并) 3.输入的文件可能带路径，记录文件名称不能带路径输入描述:123一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。 文件路径为windows格式 如：E:\V1R2\product\fpgadrive.c 1325输出描述:1234将所有的记录统计并将结果输出，格式：文件名代码行数数目，一个空格隔开，如: fpgadrive.c 1325 1 结果根据数目从多到少排序，数目相同的情况下，按照输入第一次出现顺序排序。 如果超过8条记录，则只输出前8条记录. 如果文件名的长度超过16个字符，则只输出后16个字符示例1输入1E:\V1R2\product\fpgadrive.c 1325输出1fpgadrive.c 1325 1Answer 2:在这道题，就发生了一件让我很崩溃的事情，那就是明明输入输出都一模一样，但就是判我错。我。。。。我也不知道怎么办，又没有原因。。。但查漏补缺才是最重要的，在这道题中，我发现了几个问题：1、在input.next()里面，不接受存在空格的字符串，因为在input.next()里面，空格使输入结束的标志之一，详情请看我在第一题的分析，所以因为输入的文件名和行数之间存在空格，必须使用nextLine()，否则就必须分开两次输入，路径名用next()，行号用nextInt() ，当然循环还是用hasNext()。2、面对这样的一个输入1E:\V1R2\product\fpgadrive.c 1325我的本意是，首先将整个按空格切分为路径 + 行号的组合，但是忽略了next和nextLine的区别。于是转为路径用next，行号用nextInt()的方法。不过呢，这有一个bug。众所周知，在windows系统的c盘里面，有一个文件名为program file，它是我们安装文件的路径。。。。所以，这其实是一个潜在bug。先看重点，我们获取了路径，因为我们存储的是文件名，所以理所当然的，我们就对路径做split切分，以反斜杠为准。然而就是这里出了问题。1使用 str.split("\");是错的。str.split("\\")也是错的。必须使用str.split("\\\\");3、题目要求最终按照记录数的多少，降序排序。那么在hashmap这里面怎么降序排序？？这个是我以前没用过的，直到google一下，才发现，要用比较器1234567891011121314151617List&lt;Entry&lt;String, Integer&gt;&gt; list;list = new ArrayList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet());Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123; public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123; //这里如果是o1.getValue() - o2.getValue()就是升序，下面的是降序 return (o2.getValue() - o1.getValue()); &#125;&#125;);int index = 0;//对hashmap的遍历，基本都是将key放在一个list里面，然后从list拿出来。for (Entry&lt;String, Integer&gt; t : list) &#123; if (index == 8) &#123; break; &#125; index ++; System.out.print(t.getKey() + " " + t.getValue() + " ");&#125;4、题目要求数目相同的情况下，按照输入第一次出现顺序排序这里就要求我们要将hashmap插入时的时间顺序记住。但也正是这里，让我感觉头疼，如果再建一个结构来存储他们的时间，可以是可以，但这代码我自己都看不下去，我总觉得一定有更好的方法，果不其然，我发现了hashMap是不存储插入顺序的，但是hashmap的子类LinkedHashMap会。因为linked结构，所以查找会相比于hashmap慢一些，但是技术这种东西，没有好不好，只有适不适合。。我觉得，今天就是LinkedHashMap大显身手爆锤hashmap的时候了哈哈哈哈哈哈哈。附上第二题代码（谨慎参考，因为虽然与系统答案一致，但是牛客毕竟判我错）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.LinkedHashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); Map&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;(); List&lt;String&gt; inputList = new LinkedList&lt;String&gt;(); while (input.hasNext()) &#123; String dir = input.next(); int lineNum = input.nextInt(); String[] fileNames = dir.split("\\\\"); String finalName = fileNames[fileNames.length - 1]; finalName = finalName + " " + lineNum; if (map.containsKey(finalName)) &#123; int value = map.get(finalName); map.put(lengthMoreSixteen(finalName), ++value); &#125; else &#123; map.put(lengthMoreSixteen(finalName), 1); &#125; &#125; List&lt;Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet()); Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123; public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123; return (o2.getValue() - o1.getValue()); &#125; &#125;); int index = 0; for (Entry&lt;String, Integer&gt; t : list) &#123; if (index == 8) &#123; break; &#125; index ++; System.out.print(t.getKey() + " " + t.getValue() + " "); &#125; &#125; static String lengthMoreSixteen(String finalName) &#123; if (finalName.length() &gt; 21) &#123; finalName = finalName.substring(finalName.length() - 21); &#125; return finalName; &#125;&#125;Question3：扑克牌大小123456789101112131415扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:) 3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER 输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR 基本规则: （1）输入每手牌可能是个子，对子，顺子（连续5张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列； （2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子） （3）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌； （4）输入的两手牌不会出现相等的情况。 提示：（1）除了炸弹和对王之外，其他必须同类型比较。 （2）输入已经保证合法性，不用检查输入是否是合法的牌。 （3）输入的顺子已经经过从小到大排序，因此不用再排序了.输入描述:1输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如4 4 4 4-joker JOKER。输出描述:1输出两手牌中较大的那手，不含连接符，扑克牌顺序不变，仍以空格隔开；如果不存在比较关系则输出ERROR。示例1输入14 4 4 4-joker JOKER输出1joker JOKERAnswer 3:第三题我想做，但是。。。我看不懂题目。。。我们自己玩扑克，没这么多叫法。。。我要去了解下规则，才能做这道题。。。。]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由树的前序和中序遍历，构建二叉树的后序遍历]]></title>
    <url>%2F2020%2F02%2F29%2F%E7%94%B1%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[QUESTION:给定二叉树的前序（GDAFEMHZ）中序遍历（ADEFGHMZ）、输出二叉树的后序遍历(剑指offer原题) 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。ANSWER:在二叉树的构建中，我们首先有了一个前序一个中序。如这道题目里面，假设存在12String preStr = "GDAFEMHZ";String midStr = "ADEFGHMZ";这两个，其中preStr是前序输出，midStr是中序输出。显然，因为前序必然是从根节点开始的，所以1、G必然是根节点。在中序遍历中，根节点的存在，必然是将二叉树左右分的存在。即在中序遍历中，左边是他的左节点，右边是他的右节点，所以2、ADEF是根节点G的左节点，HMZ是根节点G的右节点。由于G存在左节点，而根据中序遍历的定义，显然，根节点G的下一个左节点，成为G左子树中的根节点。就如这张图片所显示的在这张图片中，虽然6是根节点，但是2同样可以作为6的整个左子树的根节点，同理，8也可以作为6的整个右子树的根节点。从这里我们不难发现，此处出现了一个递归规律，那就是，我们可以类似于树的递归遍历那样，首先从6根节点出发，然后将6.left再一次放入递归函数中，再将6.left.left放入递归函数中，直至6.left.left……..left.left == null，我们就可以return null，使之回到上一级，进入6.left.left……left.right。于是乎，树的构建规律便显现出来了，通过递归我们可以构建一棵树。然后便是解决各个节点所安放的位置了。我们再回到上面那个图片，从中可以明显看出，该树的前序中序遍历是1前序 6 2 0 1 4 5 8 91中序 0 1 2 4 5 6 8 9其遍历路径，是从6开始，一直向左节点走到尽头0，再去探访尽头的右节点1，探访完，就回去父节点2探访右节点4……以此类推，我们可以发现，这个前序遍历的规律，便是我们上面发现的递归规律。于是乎，一个很明显的答案便浮现出来，那就是前序遍历的顺序，正好对应前序建树的路程。我们每次先从前序队列里面拿出第一个元素 M，这个元素就是一整棵树中的某一部分子树的根节点。如6是树的根节点，2是6的左子树的根节点，4是2的右子树的根节点。然后我们将中序队列按照 M 切分为两个部分，左部分元素是M节点的左子树，有部分元素是M节点的右子树。例如，我们从前序队列中找到M = 6 ，则我们将中序按照6分为两个部分为10 1 2 4 5 | 8 9显然，0 1 2 4 5 为6 的左节点，8 9 为6 的右节点。然后我们令6.left成为递归的下一个节点，于是在新一轮递归中，根节点变为了前序队列中的下一个：2紧接着，我们在按照上面的划分，将0 1 2 4 5 以2位中间分为两部分10 1 | 4 5其中，0 1 是2 的左节点，4 5 是2 的右节点。以此类题，构建一整棵树。代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package hello;import java.util.LinkedList;import java.util.List;import java.util.Queue;public class Main &#123; static Queue&lt;Character&gt; queue = new LinkedList&lt;Character&gt;(); public static void main(String args[]) &#123; //前序 String preStr = "GDAFEMHZ"; //中序 String midStr = "ADEFGHMZ"; char[] pre = preStr.toCharArray(); for(int x = 0; x &lt; pre.length; x++)&#123; queue.offer(pre[x]); &#125; TreeNode root = new TreeNode(queue.poll()); construct(root,midStr); preOrder(root); &#125; static void preOrder(TreeNode root)&#123; if(root==null) //如果结点为空则返回 return; preOrder(root.left);//访问左孩子 preOrder(root.right);//访问右孩子 System.out.print(root.val + " ");//访问根节点 &#125; static TreeNode construct(TreeNode root,String arr)&#123; //根据根节点，将中序遍历的剩余子节点切分为左右两半，若是左边有元素，则该节点存在左孩子，若是右边有元素，则该节点存在右孩子 String[] leftAndRight = arr.split(String.valueOf(root.val));//经过这个切分，leftAndRight成为一个数组 if(leftAndRight.length == 0)&#123;//若是左边为空，说明左孩子已经走到了尽头，往下走不会再有孩子了，应该回退到上一级，看看上一级有没有右孩子 return null; &#125;else if(leftAndRight[0].length() == 0)&#123;//若是左边不为空，要判断左边的元素数组个数，当然左边是可以不设置的，但是为了和右边相对称，还是写上吧。 return null; &#125;else&#123;//如果左边不为空，且左边的元素不是“”值，则说明必然存在左节点。 char rootVal = queue.poll();//从队列中提取元素，作为当前节点的做孩子节点，并且将左孩子放入递归算法中。 TreeNode left = new TreeNode(rootVal); root.left = left; construct(root.left, leftAndRight[0]); &#125; //若是左边为空，说明左孩子已经走到了尽头，往下走不会再有孩子了，应该回退到上一级，看看上一级有没有右孩子 //而且第二个判断条件 || leftAndRight.length == 1，是因为如果leftAndRight的长度只为1，那么其实这个1是左孩子的1，不是右孩子的，说明右孩子还是为空。 //记住这个判定条件，我在这里卡了很久。 //超级重要，因为如果不加如这个判定条件，那么程序就会直接执行到添加右节点的语句中，那么就会把HMZ这三个右节点的属性，给错放到根节点的左子树中。不信你试试 if(leftAndRight.length == 0 || leftAndRight.length == 1)&#123; return null; &#125;else if(leftAndRight[1].length() == 0)&#123; return null; &#125;else&#123; char rootVal = queue.poll(); TreeNode right = new TreeNode(rootVal); root.right = right; construct(root.right, leftAndRight[1]); &#125; return root; &#125;&#125;class TreeNode &#123; TreeNode left; TreeNode right; char val; TreeNode(char val) &#123; this.val = val; &#125;&#125;以上。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>树</tag>
        <tag>剑指OFFER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个智能问答系统的自然语言处理机制（一）]]></title>
    <url>%2F2020%2F02%2F29%2F%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[​ 在当前人工智能背景下，计算机视觉、机器学习和自然语言处理等等共同作为人工智能大树的分支而并列共存。​ 谈及自然语言，从语言的语法体系出现以来，我们便一直使用词性、主谓宾等等句子结构来分析句子，自然而然的，我们倾向于让计算机使用人类的思维去理解句子，然而经过几十年的探索，我们才不得不承认这个尝试失败了。​ 如今，已经不会再有计算机科学家再继续坚持使用传统人类的语法规则去让计算机理解语言，而是使用了基于统计语言模型的数学模型，它是所有自然语言处理的基础，并且广泛应用于机器翻译、语音识别、手写输入等。​ 自然语言处理是人工智能体系中的一个大分支，它回答了机器是如何使用数学模型来解决中文分词问题，并且尝试让机器去理解这一段话。​ 这篇总结，是我基于项目而归纳出的一点心得，后续再整理补充。​ 项目代码源于github：https://github.com/AnchengXu/Spring-Boot-Neo4j-Movies​ 搭建过程源于CSDN：https://blog.csdn.net/appleyk/article/details/80331997序言​ 我们在做自然语言处理时（针对特定主体的，基于检索的模型），首先需要明白一个重点，那就是一个自然文本中，重点永远是名词。这个名词可能是事物（太阳、晋升）、人名（周星驰）、电影名（大话西游）、角色名（总经理）等等，这些名词中，有些是大部分文本处理框架中自带的，而有些是需要自己自定义词典，然后导入到1CustomDictionary.add(word, "nm 0");中的。​ 就以电影知识问答系统而言，一个关于电影主题的句子，必然是围绕着一个主体，然后进行着一系列动作的。于是，每一个句子，基本都可以划分为1nr() 的 nm() 分数/简介/演员/评价基本也就这个框架了。​ 从这个项目中，有一个点我不知道对不对，但是在这个项目中是可以的，那就是自然语言处理中，对文本的角色识别，基本都是对名词的识别，然后针对特定主主题的动词，诸如分数、简介、演员列表、评价等等，这些都应该是自定义词典然后进行文本匹配的。如果是无主题的问答系统，那么自然是一个庞大的工程，但是这是基于检索的特定主题的nlp，所以自定义一个词典，我个人感觉是不难的。​ 而且这个项目有个很大的问题，那就是在ModelPrecess.java中，根据spark的贝叶斯分类后，进行123double[] testArray = sentenceToArrays(sentence);Vector v = Vectors.dense(testArray);double index = nbModel.predict(v);预测得到的index，但是这个预测有个很大的问题，因为在这个程序中，对于v向量的描述是人工添加的某些字段组合而成，也就是说，你问的问题，除了名词即角色主体之外，必须包含有vocabulary.txt其中的190个字段，如此必须具备多个字段，这样spark的贝叶斯分类器才能将14个模板问题区分开，一、载入190个单词的词汇表​ 将那个词汇表载入内存中，我们到时需要将一个问题切分，然后进行遍历，与这个词汇表进行比对，从而了解这个问题到底在说什么。1vocabulary = loadVocabulary();二、载入13个归类问题的训练数据问题表​ 这是所有问题的最终13个答案，是通过不断评分，最后得出的13个可以被机器理解的问题。1questionsPattern = loadQuestionsPattern();三、载入所有问题数据​ 这是spark训练的13个多个问题回答样式，spark将通过学习，知道哪些问题是回答评分，哪些问题是回答出生日期。1public NaiveBayesModel loadClassifierModel()四、创建训练模型生成训练器的主体，spark程序对象123456789一、生成Spark对象Spark程序是通过SparkContext发布到Spark集群的Spark程序的运行都是在SparkContext为核心的调度器的指挥下进行的Spark程序的结束是以SparkContext结束作为结束JavaSparkContext对象用来创建Spark的核心RDD的注意：第一个RDD,一定是由SparkContext来创建的二、SparkContext的主构造器参数为 SparkConfSparkConf必须设置appname和master，否则会报错12SparkConf conf = new SparkConf().setAppName("NaiveBayesTest").setMaster("local[*]");JavaSparkContext sc = new JavaSparkContext(conf);生成训练集LabelPoint​ 定义一个train_list,该变量中，存储13个问题文件一共近100个问题的Labelpoint，而labelpoint是由Vector组成的。1List&lt;LabeledPoint&gt; train_list = new LinkedList&lt;LabeledPoint&gt;();​ labelpoint要么是稀疏，要么是密集。将一个问题文件中，如“出生日期.txt”中的10个问题，进行逐个的拆分，每一个问题都要转为double型数组，然后将这个数组转为Vector向量，可以是稀疏性、可以使密集型向量均可。1double[] array = sentenceToArrays(sentence);​ 紧接着将Vector向量转为labelpoint，因为只有labelpoint才能被spark进行识别并且计算分类。12LabeledPoint train_one = new LabeledPoint(0.0, Vectors.dense(array));train_list.add(train_one);​ 13个问题文件全部都要这样去载入。创建RDD​ java创建JavaRdd，并将上面的train_list放入javardd中进行训练，得到Spark贝叶斯分类器NaiveBayesModel12JavaRDD&lt;LabeledPoint&gt; trainingRDD = sc.parallelize(train_list); NaiveBayesModel nb_model = NaiveBayes.train(trainingRDD.rdd());缓冲读入​ 将自己收集的数据，进行缓冲读入，例如将所有的电影名字放在一个txt文件中，然后用下面这句话进行读入到BufferedReader1BufferedReader br = new BufferedReader(new FileReader(new File(path)));放入Hanlp中的自定义字典中​ 将从缓冲读入取得br，根据字典的不同或者词性的不同，存入 Hanlp中的类库CustomDictionary中，12345678910111213141516171819202122232425String word;while ((word = br.readLine()) != null) &#123; switch (type) &#123; /** * 设置电影名词词性 == nm 0 */ case 0: CustomDictionary.add(word, "nm 0"); break; /** * 设置电影类型名词 词性 == ng 0 */ case 1: CustomDictionary.add(word, "ng 0"); break; /** * 设置电影评分数词 词性 == x 0 */ case 2: CustomDictionary.add(word, "x 0"); break; default: break; &#125;&#125;五 分析问题，开始问题处理对文本进行分词处理，抽象提取​ 用hanlp，对一个问题如”吴孟达”，会进行分词，并且进行词汇的抽象分析，比如“吴孟达”，就会被hanlp的人名词典进行辨识，如果在人名词典（可能是日文、或者汉化英文名）找到了，那么在后缀加上nr的nature标识，或者也可以去自定义的人名词典去搜寻，找到了，也可以添加自定义的后缀nature标识。123456/** * 抽象句子，利用HanPL分词，将关键字进行词性抽象 * 先抽象，比如将人名全部改为nr，其主要目的是为了简化句子，只剩下190个关键词进行匹配*/// 句子抽象化 Segment segment = HanLP.newSegment().enableCustomDictionary(true); //使用segment将querySentence句子做切分，切分成多个词 List&lt;Term&gt; terms = segment.seg(querySentence);12345for (Term term : terms)if (termStr.contains("nr") &amp;&amp; nrCount == 0) &#123; //nr 人名 abstractQuery += "nnt "; abstractMap.put("nnt", word); nrCount++;​ 于是，“吴孟达”就变成了“nnt”。将拿到的“nnt”与spark训练过的模板比对​ 根据概率，拿到相对应的回答模板尾、尚未理解的问题NativeBayesModel.predict()方法​ NativeBayesModel.predict()方法到底是怎么进行归类实现的，浅显的原理大家都懂，毕竟只要说“随着新的数据，能够不断更新旧的概率，使得更可靠”，但是实现怎么做？？？NativeBayesModel.predictProbabilities()方法​ NativeBayesModel.predictProbabilities()方法这tm概率怎么算的？？？]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>检索匹配</tag>
        <tag>贝叶斯</tag>
        <tag>问答系统</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在链表中判断环的存在]]></title>
    <url>%2F2020%2F02%2F28%2F%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A4%E6%96%AD%E7%8E%AF%E7%9A%84%E5%AD%98%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[Question:​ Given a linked list, determine if it has a cycle in it.​ 给定一个链表，判断链表中是否有环。​ 给出推理验证过程，以及代码实现（JAVA）。Answer：​ 由反证法证明，在一个有环的链表中​ 假设有两个人从起点A开始向后走，其中m每次走两步，n每次走一步。显然，在第一次走了之后，m = 2，n = 1，此后，m &gt; n 永远成立。若是这个链表无环，m和n必然无法相会，因为n永远追不上m。​ 记住这是前提，也就是说，如果无环，二者在起点之后必然永不相遇。​ 但是如果有环，则m在走的快之后，必然会回到m自己走过的路上，这个路可能是n走过的，也可能是n尚未走过的。​ 1、如果m经过环到了n的后方，那么不管怎么样走，m和n必然能到达最后两种情况：要么相遇，要么只相差一个节点。​ 如果直接相遇，那么就说明违背了前提——无环则永不相遇，有反证法可知，链表存在环。​ 如果只相差一个节点，即 n - m = 1，那么下一步，n + 1 = m + 2 ， 于是二者相遇，违背了前提——无环永 不相遇，有反证法可知，链表存在环。​ 2、如果m经过环跳转到n的前方，那么不管怎么走，m必然达到这么一种情况：不断在环内行走，直到n走到这个环内，于是回到了1的情况中，二者必然相遇。​ 依据这个证明，我们可以写出证明方法123456789101112131415public boolean isCircle(Node headNode)&#123; if(headNode == null || headNode.next() == null)&#123;//头结点为空，或者链表只有首结点 return false; &#125; Node NRunner = headNode.next(); Node MRunner = headNode.next().next(); while(NRunner.next() != null &amp;&amp; MRunner.next() != null)&#123; NRunner = NRunner.next(); MRunner = MRunner.next().next(); if(NRunner == MRunner)&#123; return true; &#125; &#125; return false;&#125;得证，以上。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定期感情清零]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%AE%9A%E6%9C%9F%E6%84%9F%E6%83%85%E6%B8%85%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[今天分享一篇日记。日记的主人 Pill，是一位几乎没有恋爱经验的女生。她在最近一次“尝试恋爱”之后，记录了自己的全部感受。而「定期情感清零」，是她认为必要的步骤。日记并不长。今天，就不妨试着没有负担地阅读，走进她那变得平和的感情世界里。2019 年的第一份喜欢，像夏天里的第一口冰可乐，碳酸饮料式的热烈，但消淡的速度也很快。停止喜欢快一个月了。我没有再像以前一样，花费很多时间去想为什么。我原本以为自己喜欢得热烈，但原来也不过如此。我也觉得我应该会难过的，但我没有。反倒觉得松了一口气，因为我不用再因为对方的一句话，就轻易地开心或不开心。在这件事上，我发现，自己面对情感关系时终于成熟了一点：不再长久地纠结一段不重要的关系。梁文道在《我执》里写过一段话：第一次和他吃饭，他看到背后的墙上有只漂亮的碟子，来自罗马一家著名的餐厅。大概是一时兴奋，他冲口而出：“我们以后一定要去那里吃。”后来我一直反复琢磨，他说的，到底是“我”，还是“我们”呢？如果是随兴的话，“我”和“我们”又有什么分别？我又何必煞费思量？我也曾经煞费思量，纠结在“我”和“我们”之间。这令人伤脑筋，也很耗费心力。但这次我没有。我懒得去计较这段关系中，哪一个表情是真心的，哪一句话又是假的。他有说过打动我的话，也有过令我误会的动作。但在结束之后，我没有再像以前一样，温存着那些话语和动作。我在心里自嘲，这算是一种进步吧。还能记得的画面是，最后一次一起坐地铁，他快到站要下车了。我问他，“以后还会再见面吗？”他笑着说，“会的。”车门打开。他摸了摸我的头，下车，又在门口转过身来，再次挥手和我说拜拜。我那时也相信，是会再见面的。但现在想来，他会回头，也是觉得我们不会再见面了。这个画面我一直记得，是因为在后来的日子里想起来，我觉得那就是一个信号，一个对方会离开我生活的信号。他从未和我说过，他有女朋友，所以通过别人口中知道之后，我快速地停止了喜欢。我退出得很快，甚至带着一种无所谓的坦荡。“反正他既不是我喜欢得最多的一个，也不是最好的一个。”删掉所有聊天记录的那天晚上，我和同事说，想吃水果，吃很多很多水果。于是我们三个人去水果店，买了 150 块钱水果。然后坐在便利店里，大口大口地咀嚼着西瓜和菠萝。甜味就像一种万能的溶液，把我所有的情绪都溶解掉。很奇怪，我过得比以前快乐更多，生活里的各种情绪，也比以前更加明显和热烈。某一天我才想通了为什么，大概是我的胜负心仍然在作祟。因为在喜欢他的时间里，我在他那里失去的筹码太多了。所以不喜欢他之后，我一点也不愿意失落和难过，这样会失去更多的筹码。我想起以前，得不到喜欢的人，会故意透露自己的难受，企图让对方觉得内疚。我在朋友圈发自己在操场上坐着的图，然后说，“好想学会喝酒啊，这样就可以忘掉所有烦心事了。”我还说，“春天会过去的，真心也会。”这些都是发给特定的人看的，我想着，要是他知道我的难受就好了。但其实，一段关系中，内疚是无用的。一来是对方可能压根就不在意你，二来就算是内疚，也并不能转化为喜欢。很多女孩在爱情中都变得傻傻的，傻到可以将很多种感觉都混淆成喜欢。说白了也不是混淆，只是因为“被骗”。被对方骗，被自己骗。这都是，我经历过一些失败关系后，才明白的道理。另一点是，这段关系让我对“付出真心”这件事，产生了一些后怕。朋友 Kitty 说，你永远不知道，自己的真心会以哪种方式被浪费掉。这句话戳到我了。这几天皮卡丘大电影上映，我老是想起我的可达鸭。那是吃麦当劳开心乐园套餐送的玩具，我也只有那么一只。但我送给他了。我猜，他大概早就不知道丢到什么地方去了。这可能是爱情的一点坏处？你不能保证，对方也同样珍视你付出的真心。我也听过很多爱情道理。对于一个几乎没恋爱过的人来说，身边朋友的经历总是让我引以为戒。但我慢慢发现，故事每天都在发生，每天都比昨天更狗血、更无情。时间长了，我也开始警惕起这些道理和经历。原来对一些人来说，情感关系可以只是一个游戏。一个朋友便热衷于这样的游戏。喜欢他的女孩他从不拒绝，他深谙怎样的举动可以撩到女孩，和一个人在一起不是因为喜欢，只是因为需要一个前任的替代品。我从心底里鄙夷，那些将情感当做游戏的人。正因为他们，我们遵守的情感规则才不起作用。我们认知里的爱情，也变得不再纯粹。所以我只能，祝那些视情感为游戏的人，日后想真心付出时，也遇到同等的情感玩家。写下这些的时候，我发现，自己已经想不起来，我们相处过程中的很多细节了。它们的的确确，正在清零。必须得承认的是，我在这里消耗了一些勇气，也很难再找回来。但我想，剩下的勇气，我还够用。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>恋爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础 树状数组 大数计算]]></title>
    <url>%2F2019%2F03%2F19%2FJava%E5%9F%BA%E7%A1%80-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E5%A4%A7%E6%95%B0%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[在试图解决苹果树下摘苹果的ACM题目，想要学习怎么用Java表示多叉树的时候，突然发现了这个算法，使用二分法来计算大数，且效率很高。在看到它的实现原理瞬间，着实感到惊艳。一、树状数组是干什么的？​ 平常我们会遇到一些对数组进行维护查询的操作，比较常见的如，修改某点的值、求某个区间的和，而这两种恰恰是树状数组的强项！当然，数据规模不大的时候，对于修改某点的值是非常容易的，复杂度是O(1)，但是对于求一个区间的和就要扫一遍了，复杂度是O(N)，如果实时的对数组进行M次修改或求和，最坏的情况下复杂度是O(MN)，当规模增大后这是划不来的！而树状数组干同样的事复杂度却是O(MlgN)，别小看这个lg，很大的数一lg就很小了，这个学过数学的都知道吧，不需要我说了。​ 申明一下，看下面的文章一定不要急，只需要看懂每一步最后自然就懂了。二、树状数组怎么干的？​ 先看两幅图，下面的说明都是基于这两幅图的，左边的叫A图吧，右边的叫B图： 是不是很像一颗树？对，这就是为什么叫树状数组了～先看A图，a数组就是我们要维护和查询的数组，但是其实我们整个过程中根本用不到a数组，你可以把它当作一个摆设！c数组才是我们全程关心和操纵的重心。先由图来看看c数组的规则，其中c8 = c4+c6+c7+a8，c6 = c5+a6……先不必纠结怎么做到的，我们只要知道c数组的大致规则即可，很容易知道c8表示a1～a8的和，但是c6却是表示a5～a6的和，为什么会产生这样的区别的呢？或者说发明她的人为什么这样区别对待呢？答案是，这样会使操作更简单！看到这相信有些人就有些感觉了，为什么复杂度被lg了呢？可以看到，c8可以看作a1～a8的左半边和+右半边和，而其中左半边和是确定的c4，右半边其实也是同样的规则把a5～a8一分为二……继续下去都是一分为二直到不能分，可以看看B图。怎么样 ？是不是有点二分的味道了？对，说白了树状数组就是巧妙的利用了二分，她并不神秘，关键是她的巧妙！]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>大数计算</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我从3次考研失败中明白了什么]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%88%91%E4%BB%8E3%E6%AC%A1%E8%80%83%E7%A0%94%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%98%8E%E7%99%BD%E4%BA%86%E4%BB%80%E4%B9%88-Cover%20By%20%E6%9C%A8%E5%85%B0%2F</url>
    <content type="text"><![CDATA[到今年6月，我已经大学毕业整整5年，在这5年时间我考了3次研究生，结果都失败了。考研是我这段时光最重要的一个注脚，我把它记下来，防止自己遗忘。同时也说明一下，这篇问章不是考研成功攻略，更不会回答“我该不该考研“这个问题，只是希望我用5年时间明白的一些 事情有缘人能够看到，从而对自己的生活有所启迪。https://www.douban.com/note/380061531/一：荒废大学 首次考研我是美术生，经过高中的突击专业训练还有一年的复读，以及还算不错的文化课成绩从郑州考入了广州一所中等偏上大学的美术学院。我的大学生活用“荒废”这个词概括有点后知后觉，当时的我的感受跟现在大不相同，一股子不知道自己想要什么又什么都想要的别扭劲儿，把自己拧巴得烦恼焦躁又抑郁，天天想点不着调的，又受到学校接连几场跳楼事故的影响，心理都有点异常，不得已去求助学校心理咨询，去了两次问题似乎解决了后来就又不去了，总之各种前后矛盾渴望改变又不敢行动的虚无状态。就这样到大四上学期，才突然意识到大学生活就要完结顿时慌了神，怎么才能继续留在大学这个象牙之塔呢？似乎只有考研，于是就去考了一场裸考差不多的考试，结果，可想而知。总结：这个阶段，其实问题出在两个方面，第一是初高中应试教育只注重成绩，自己完全没有培养出自制力和独立学习能力。第二就是国内大学教育的尤其是通常采用放羊式管理同时又太偏重学术性，根本与社会就业脱节，其中美术教育尤甚。我学的平面设计专业（现在都叫视觉传达）其实很好玩很实用，可以学习很多东西的学科，但学校又完全没有成熟的课程体系。这两方面相互作用，形成了我虚无主义的倾向，想得多做得少，执行力奇差，这种倾向其实从一开始的小学阶段就有，但到了大学才来了总爆发。最后应该感谢母校的心理救助体系，让我没能步几位自杀者的后尘吧!二：工作迷茫 二次考研这部分应该重点细说，估计也是很多想辞职考研同学最关心的部分。毕业后我经过大半年的曲折终于找到了一份稳定的工作。那个工作的地点在所谓开发区，道路齐整厂房俨然，绿树成荫鲜花常开，此外还有小山迤逦，单说风景简直是世外桃源。可惜枯燥也是真的，我早班车去晚上班车回，年轻的生命在大而无当的办公室里显得空空荡荡，我想这种感觉类似公务员们吧，但却远没有一般公务员轻松和稳定，首先我的工作虽然简单，却相当繁琐，工作量也不算小，一不小心就会出错，而出错就意味着投诉、扣工资、乃至开除。其次这个工作技术含量相当低，一个刚毕业的大专生培训两天就能上手随时可以被取代，这让我内心的恐慌感日益蔓延。因为我早已不是那个天真而纠结大学生，出社会的一年的经历，让我确信了一条，生存是第一位的，而理想也要很重要。我对我的以往做了简单的回顾也开始想办法去改变现状，怎么改变呢，我自然而然地想到了考研，假如我能考回母校，我一定倍加珍惜每个小时，把想学的想做的都做完，当时就是这种简单的想法（估计也是很多同学的心声）。作为一个典型的文艺青年，我的执行力一直都是渣。有了考研的计划，但我最多的时间还在纠结，期间我还回到家乡一边找了一份工作慢悠悠做着，一边跟父母兜售我的考研计划，我也像现在亲们一样，求支持，求祝福，求帮助，求鼓励，各种求。但是，父母并不支持，因为他们看来我当时的工作不能算很好，也没很坏，人也老大不小了，安安稳稳地生活最重要，考研太不着调。我期间感情也有变故，总之是受了点刺激，让我意识到只能自己靠自己了，所以我开始攒钱并且暗自制定制定了一个离家出走考研计划。2012年下半年，激动人心的时刻终于到来，我提着装有几件换洗衣服的小包，拿着几个月工资攒下来的一笔钱，坐上了南下的火车。我已经事先跟在广州的同学“密谋”好，安排好了住地和生活事宜，出发前我甚至还请了某占星师算了一算能不能考上，她总体意思是可以的，现在回想只能呵呵后了，如果我是占星师，我也不会太打击客人不是。我到了广州的时候已经是8月底，过了中秋才正式复习。我那时候怕英语怕的要死，每天大部分精力都投入到专业中去，晚上回到同学家里，才敢看英语。后来我看英语的时间拖延的越来越晚，不得已我只好过上了昼夜颠倒的生活，晚上看书到凌晨，困了就睡到中午，再起身去学校图书馆复习，晚上再看英语如此循环。时间过得很快，很快就到了考试的日子，拜混乱的生物钟和紧张情绪所赐，我在英语考试前晚华丽失眠。浑浑噩噩出了考场，像死过一回的感觉。专业相对轻松吧，反正填满了卷子。最后我的成绩出来了，总分340还不算太难看（艺术类总分最低线320），但英语只有32，差当年最低分数线2分。专业还行，我不死心打电话给导师，导师说别说你没上线，就是上了线，比你高二三十分的都不知道录不录呢！但是当时我是把这句话选择性地遗忘了。总结：这次考研其实我犯了两大错误，第一拖了太久，如果我当时能把那份稳定工作的业余时间都用来看英语，搬到公司宿舍节省一些费用也攒点钱，其实完全可以不用从广州折腾到家里又从家里跑回广州也不用寻求任何人的支持。第二就是完全低估了美术史论考研的难度，预留了太少的复习时间。而且考前我找过导师，导师首先告诉了我很多现实的问题，但我只是一头热的选择性忽略，换言之，执行力差什么的不是最致命的，不相信现实只愿意相信自己相信的才是最致命的。三：前途混沌 三次考研灰头土脸回到家里，父母并没有对不告而别的我大发雷霆，但是我自己情绪低落的不可自拔。因为当时成绩还没出来，也没打算找工作，所以暂时就在家里的小作坊打杂，反正什么都学什么都做吧，做饭刷碗画图接待客人。可以想象从美丽的南国校园，到尘土飞扬的北方城乡结合部小作坊区可以想象我的心理落差~一次系着那种丑到爆的罩衣刚做完大锅饭，一个客户正好回市区，于是就坐在他面包车后箱的麻袋上趁车回家，客户边开车还边跟我聊天，他说看你这么年轻怎么跑去给人家做饭。听完之后心里不知道是什么滋味，总之是百味陈杂。我没有嫌弃做饭工作，好歹也是自食其力，哪怕是个作坊做饭的也没什么，但我想起了自己种种美好的过往时光，以及曾经五彩斑斓的梦想，还有两分而不过线的巨大遗憾，考研，又像一条滑溜溜的蛇钻入脑门。我又一次向父母提出考研，经过了上次的离家出走，他们对我考研执念体会深刻，这次他们也没多说什么。我回到家里市区的套房，专心准备考研。这回我从现实考虑，已经不打算考回母校了毕竟山长水远的，综合考虑本地的一所重点大学才是最佳选择。于是我买齐资料，开始复习。那段日子颇像闭关修行，我吸取第二次的教训，按时作息，劳逸结合，还要感谢我在毕业之后学会的新技能——做饭，我的三餐荤素搭配，颇有营养，还能顺道给父母准备早晚餐。但我的内心还是有种种焦虑不安，被我用表面的意志勉力压制，最后还是来了个大爆发。考前两星期我连续3天失眠，后来我想来想去睡不好是个大问题，平生第一次去医院精神科开安眠药，那个女医师听到我的失眠原因之后哑然失笑，说你们年轻人就是这么脆弱，可能这件事在她眼里根本不算事儿吧！总之吃了安眠药之后我睡眠就还算正常了。考试考的很快，没有失眠没有意外。唯一比较吃惊的是，考研人数异常的多，还有绝大部分都是女生。这次我英语考了38，过了线可依然没考上，母校导师的话就被我重新从记忆里翻出，当时我是选择性地遗忘了的。总结：其实这次考研更多的对上次不过线的不甘心吧！还有我其实对当时自己窝在家里的现状及其不满意，却没有更多的改变勇气。这次从策略上来说，还是客场作战，对专业题型、题量都没有一个准确的估计，更是低估了大家考研的热度。不过无所谓了，在那场闭关之中我也想明白了一些道理，自己放过了自己。后记我的三次考研，其实都是在打一场开始就能猜到结果的必败战争。有时候我也想，如果我考研之前就明白这些道理就好了~但是跟那个八个烧饼的故事是一样的，是不可能的。我也问我自己有没有后悔，真的没有。因为对当时的我来说，考研是最重要的可以抛下其它一切。世人都很重视结果，就好像烧开水，没烧到100°C就算失败，可是我自己知道，我可能烧的时间有点短，可能第一次是50°C第二次是70°C一直在进步，他们看不到可是我自己知道。现在我知道了我把考研当成了一个魔法石，我对过往的遗憾，对现实的失望，对未来的期许，学习的欲望，改变的渴望等等等等，似乎用一个考研成功都能点石成金重头再来。我常常想如果说六零后的青春背景是那一场史无前例的浩劫，还有上山下乡谱写的青春挽歌，七零后的青春是文艺的黄金时代还有那个广场前的不可言说。那么，我们八零后的青春背景就是大学扩招以及考研热考公务员热 留在北上广和逃离北上广的纠结~时代的洪流滚滚而来，我们被夹裹其中来不及思考就要匆匆向前。我用的的青春经历了考研，它给我的影响将持续一生。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果树下摘苹果——ACM选拔题目训练（Easy难度）]]></title>
    <url>%2F2019%2F03%2F16%2F%E8%8B%B9%E6%9E%9C%E6%A0%91%E4%B8%8B%E6%91%98%E8%8B%B9%E6%9E%9C%E2%80%94%E2%80%94ACM%E9%80%89%E6%8B%94%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83%EF%BC%88Easy%E9%9A%BE%E5%BA%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DescriptionThere is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree.The tree has N forks which are connected by branches. Kaka numbers the forks by 1 to N and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree.The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka?中文描述卡卡家外面有一棵苹果树。每年秋天，树上都会长出许多苹果。卡卡非常喜欢苹果，所以他一直在精心培育大苹果树。这棵树有N个叉子，它们通过树枝相连。卡卡用1到n给叉编号，而根总是用1编号。苹果会在叉子上生长，两个苹果不会在同一个叉子上生长。为了研究苹果树的生产能力，卡卡想知道一个子树里有多少苹果。问题是，一个新苹果可能会在一个空叉子上生长一段时间，卡卡可能会从树上摘一个苹果作为甜点。你能帮卡卡吗？InputThe first line contains an integer N (N ≤ 100,000) , which is the number of the forks in the tree.The following N - 1 lines each contain two integers u and v, which means fork u and fork v are connected by a branch.The next line contains an integer M (M ≤ 100,000).The following M lines each contain a message which is either“C x“ which means the existence of the apple on fork x has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.or“Q x“ which means an inquiry for the number of apples in the sub-tree above the fork x, including the apple (if exists) on the fork xNote the tree is full of apples at the beginning第一行包含一个整数n（n≤100000），它是树中的叉数。下面的n-1行分别包含两个整数u和v，这意味着fork u和fork v通过分支连接。下一行包含整数m（m≤100000）。以下M行中的每一行都包含一条消息，“C x”表示叉x上苹果的存在已经改变。也就是说，如果叉子上有一个苹果，那么卡卡就会摘下来；否则，一个新的苹果就会长在空叉子上。或“Q x”表示对叉X上方子树中苹果数量的查询，包括叉X上的苹果（如果存在）。注意：这棵树一开始就满是苹果OutputFor every inquiry, output the correspond answer per line.Sample Input123456731 21 33Q 1C 2Q 1Sample Output1232自序这里一开始我就意识到要用到树的数据结构来遍历和增加节点，但是我开始以为是二叉树，随后在老师的提醒下发现并不是二叉树，而是随意树。这就有点尴尬，二叉树我都忘得差不多了，你还要给我个树，我TM怎么记得是怎么表示的啊？我甚至开始还以为要用二维数组来表示树，最后发现是我太天真。当然能够将树忘得这么干净，我也确实是太自傲了。我总以为我记得那些图、树、链表等等东西，总感觉随便一个人来面试我我都没问题，结果一道小题目就让我跪了。数据结构的基础，我真的没我想象中的那么好，甚至是曾经难以相信的差。在考场上我不断不断地问我自己，树怎么表示？用数组怎么表示？树的节点怎么定义？树的遍历怎么搞？最简单的前序遍历的递归方式怎么写？怎么添加节点和修改节点？最后我不得不承认，我确实忘得一干二净，在考场上开始垂头丧气，挣扎了那么久，最后12点整了，还是没做出来。如今趁着余温未散，搜到了这个题目的原题，再复习一遍数据结构的树。快速复习树的百科废话定义树状图是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；树（tree）是包含n（n&gt;=0）个结点的有穷集，其中：每个元素称为结点（node）；有一个特定的结点被称为根结点或树根（root）。除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，……Tm-1，其中每一个集合Ti（1&lt;=i&lt;=m）本身也是一棵树，被称作原树的子树（subtree）。我们可以形式地给出树的递归定义如下:单个结点是一棵树，树根就是该结点本身。设T1,T2,..,Tk是树，它们的根结点分别为n1,n2,..,nk。用一个新结点n作为n1,n2,..,nk的父亲，则得到一棵新树，结点n就是新树的根。我们称n1,n2,..,nk为一组兄弟结点，它们都是结点n的子结点。我们还称T1,T2,..,Tk为结点n的子树。空集合也是树，称为空树。空树中没有结点。相关术语节点的度：一个节点含有的子树的个数称为该节点的度；叶节点或终端节点：度为0的节点称为叶节点；非终端节点或分支节点：度不为0的节点；双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；兄弟节点：具有相同父节点的节点互称为兄弟节点；树的度：一棵树中，最大的节点的度称为树的度；节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；树的高度或深度：树中节点的最大层次；堂兄弟节点：双亲在同一层的节点互为堂兄弟；节点的祖先：从根到该节点所经分支上的所有节点；子孙：以某节点为根的子树中任一节点都称为该节点的子孙。森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；种类无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；二叉树：每个节点最多含有两个子树的树称为二叉树；完全二叉树满二叉树霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；深度定义一棵树的根结点层次为1，其他节点的层次是其父结点层次加1。一棵树中所有结点的层次的最大值称为这棵树的深度。符号表达法用括号先将根结点放入一对圆括号中，然后把它的子树由左至右的顺序放入括号中，而对子树也采用同样的方法处理；同层子树与它的根结点用圆括号括起来，同层子树之间用逗号隔开，最后用闭括号括起来。如前文树形表示法可以表示为：（1（2（5（9，10）），3（6，7），4（8）））遍历表达法遍历表达法有3种方法：先序遍历中序遍历后序遍历例如右图：其先序遍历为ABDECF其中序遍历为DBEAFC其后序遍历为DEBFCA自己实现我在经过一个下午的煎熬，从下午一点多到如今，中间吃个饭睡个觉，然后便被这道题纠缠住。我其实不得不承认了，我过往没学过多叉树的实现，不知道用链表实现多叉树的原理所在。而只是一厢情愿的认为二叉树和树差不了多少，其实也确实差不了多少，但问题在于我总静不下心去看那些实现源码，不愿意去思考Node节点代码中为什么要设置一个ParentId和SelfId，不知道LinkList应该写在Node节点代码中，还是写在NodeTree的代码中，我不知道在用链表实现树的过程中，应该分3层——一层Node、一层NodeTree、最上面一层NodeTreeLink，还是分2层——直接一层Node、最上面一层NodeTreeLink无数问题在困扰着我，而我还天真的以为数据结构学的多好，以为多叉树和二叉树差不多，以为Java实现会更容易，以为我能手动实现一遍树，以为我自己能直接推导。。被打脸的好狠只能留下这个坑，日后再来弄吧（2019.3.17）好了，我回来了（2019.3.19）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import java.util.LinkedList;import java.util.Scanner;public class AppleTest2 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int branchNum = input.nextInt(); AppleNodeTree tree = new AppleNodeTree(); TreeNode root = new TreeNode(); tree.insert(root, root, 0);//这里我遇到了一个问题，那就是我要怎么将第一个节点插入到tree里面呢？此时tree是空的，我也找不到父节点，怎么插入？ //答案就是第一个节点本身就是树，所以本质上插入第一个节点，就是自己插入自己。但是有一个问题，因为第一个节点本身已经是树了，所以后面使用insert方法的时候，tree会默认缺失首节点的个数 //即如果一共有5个节点，那么display方法只能显示4个节点，原因一言难尽，主要还是归因于我对树的结构的不理解吧 //我的解决方法，就是在display方法中做一个判断，让第一个节点也能够显示 for (int x = 0; x &lt; branchNum - 1; x++) &#123;// 为什么要减一？因为如果要求输入5根树枝，那么你只能输入4根，原因是，第一根已经确定为1了。无法修改 int parentId = input.nextInt(); int myselfId = input.nextInt(); TreeNode insertNode = new TreeNode(myselfId, parentId); tree.insert(root, insertNode, parentId); &#125; tree.display(root, 0); // 正式开始 System.out.println(); int operationTime = input.nextInt(); for (int x = 0; x &lt; operationTime; x++) &#123; String operation = input.next(); char operationType = operation.charAt(0); int operationLocation = input.nextInt(); if (operationType == 'Q') &#123; tree.countApple(operationLocation, root, false); System.out.println(tree.countAppleNumber); tree.countAppleNumber = 0;//在每次查询之后，必须重新设置为0，不然这个值会累积，导致最终结果出错 &#125;else&#123; tree.editApple(operationLocation, root); &#125; &#125; &#125;&#125;class TreeNode &#123; private int myselfId;//自身的标识ID，对于别人来说，这个自身id将成为别人的父id标识 private int parentId; private boolean hasApple; private LinkedList&lt;TreeNode&gt; list; public TreeNode() &#123; myselfId = 1; parentId = 0; hasApple = true; list = new LinkedList&lt;&gt;(); &#125; public TreeNode(int myselfId, int parentId) &#123; this.myselfId = myselfId; this.parentId = parentId; hasApple = true; list = new LinkedList&lt;&gt;(); &#125; public boolean isHasApple() &#123; return hasApple; &#125; public void setHasApple(boolean hasApple) &#123; this.hasApple = hasApple; &#125; public int getMyselfId() &#123; return myselfId; &#125; public void setMyselfId(int myselfId) &#123; this.myselfId = myselfId; &#125; public int getParentId() &#123; return parentId; &#125; public void setParentId(int parentId) &#123; this.parentId = parentId; &#125; public LinkedList&lt;TreeNode&gt; getList() &#123; return list; &#125; public void setList(LinkedList&lt;TreeNode&gt; list) &#123; this.list = list; &#125;&#125;class AppleNodeTree &#123; public static int countAppleNumber = 0;//这个共享变量是为了计算苹果数，但是需要记住，每次查询之后一定要重新归零，不然会累积的 public AppleNodeTree() &#123; TreeNode root = new TreeNode(); &#125; public void display(TreeNode currentRoot, int deepth) &#123;//这里的本质，其实就是不断的重新定义当前根节点，从而进行遍历.如此说来，这个深度除了显示那几个横杠--,也没有其他用处了 if (currentRoot.getMyselfId() == 1) &#123; System.out.print(currentRoot.getMyselfId() + " "); &#125; LinkedList&lt;TreeNode&gt; childList = currentRoot.getList(); if (childList == null || childList.isEmpty()) &#123; return; &#125; for (int x = 0; x &lt; childList.size(); x++) &#123; System.out.print(getLevelStar(deepth) + childList.get(x).getMyselfId() + " "); display(childList.get(x), deepth + 1); &#125; &#125; public void insert(TreeNode currentRoot, TreeNode insertNewNode, int insertNodeParentId) &#123; if (insertNodeParentId == currentRoot.getMyselfId()) &#123; currentRoot.getList().add(insertNewNode); return; &#125; LinkedList&lt;TreeNode&gt; childList = currentRoot.getList(); if (childList.isEmpty() || childList == null) &#123; return; &#125; for (int x = 0; x &lt; childList.size(); x++) &#123; insert(childList.get(x), insertNewNode, insertNodeParentId); &#125; &#125; public void countApple(int currentOperationLocation, TreeNode currentRootFindValue, boolean couldNotFindNodeFlag) &#123; //这里为什么要有一个couldNotFindNodeFlag的标识变量？原因很简单，这里计算苹果要分两步： //1.先找到那个目标子节点，而且不同于普通的递归遍历，这里如果已经找到子节点了，就不应该再去递归遍历其他的子节点了，而应该只递归遍历这个子节点的下属链表 //2.所以我们需要一个标识变量，当未找到那个目标子节点的时候，我们可以去随便遍历整个多叉树，但是一旦找到了那个目标子节点了，就修改标识变量，从而让程序只执行一部分代码了 if (currentOperationLocation == currentRootFindValue.getMyselfId() || couldNotFindNodeFlag) &#123; couldNotFindNodeFlag = true; if (currentRootFindValue.isHasApple()) &#123; countAppleNumber++; &#125; for (int x = 0; x &lt; currentRootFindValue.getList().size(); x++) &#123; countApple(currentOperationLocation, currentRootFindValue.getList().get(x), couldNotFindNodeFlag); &#125; &#125; else &#123; LinkedList&lt;TreeNode&gt; childList = currentRootFindValue.getList(); if (childList == null || childList.isEmpty()) &#123; return; &#125; for (int x = 0; x &lt; childList.size(); x++) &#123; countApple(currentOperationLocation, childList.get(x), couldNotFindNodeFlag); &#125; &#125; &#125; public void editApple(int currentOperationLocation, TreeNode currentRootFindValue) &#123; //这里也同理，未找到目标子节点之前，随便遍历，但是一旦找到了，只需一步，然后直接结束。 if(currentRootFindValue.getMyselfId() == currentOperationLocation)&#123; if(currentRootFindValue.isHasApple())&#123; currentRootFindValue.setHasApple(false); &#125;else&#123; currentRootFindValue.setHasApple(true); &#125; return; &#125; LinkedList&lt;TreeNode&gt; childList = currentRootFindValue.getList(); if(childList == null || childList.isEmpty())&#123; return; &#125; for(int x = 0;x &lt; childList.size(); x++)&#123; editApple(currentOperationLocation, childList.get(x)); &#125; &#125; public String getLevelStar(int deepth) &#123; //打印level次级符号而已 deepth += 1; char[] level = new char[deepth]; for (int x = 0; x &lt; level.length; x++) &#123; level[x] = '-'; &#125; return new String(level); &#125;&#125;对于java实现多叉树的操作，非常感谢https://blog.csdn.net/sss1342746626/article/details/78868026这个博客，让我豁然开朗，写的通俗易懂]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年Java工作经验点滴]]></title>
    <url>%2F2019%2F03%2F15%2F2018%E5%B9%B4Java%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E7%82%B9%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[​ 2018那年，我在广州实习工作近一年的工作项目小结，当然只是一部分的​ 1.如果遇到，只需向后台传送单个元素，而不是整个表单的情况的话，可以直接用jquery获取该输入框的值，然后在ajax中，使用​ $.post(path + &quot;/admin/bookManager/findTypeNameToValue&quot;,{typeName: typeName}, function (backData) {callback(backData);});​ 注意，需要自行设置传送名称和传送值，此时input中的name已经失效2.遇到需要两次转换的情况的时候，如需要将该中文转为对应的数字，然后再将该数字进行搜索的话，则要使用嵌套：&lt;u&gt;DataHandler.findTypeNameToValue(typeNameBooks, function (backDatas) {DataHandler.findTypeNameBooks(backDatas, function (backData) {console.log(backData);});});3.在dao层中，如果拼写sql语句的话，就必须执行Pagepage =this.findPageBySql方法,然而，这其中必须存在一个pageble和class文件，因此可以实现写一个无需前端js注入数值的form类，让该类集成pageble，然后使用setter方法注入，这样一石二鸟。4.在使用SpringMVC中，如果想要在controller通过return进行页面跳转，那么记得，请务必去除@ResponseBody标记，否则的话，对于SpringMVC而言，那个return “/admin/helpUp/bookManager/index” 只是返回一个字符串，而不是返回一个跳转链接5.在使用SrpingMVC跳转时，当使用return语句时，不要忘记加“/”这个斜杠。如你写的是return “admin/suggestion/index”没反应，应该写成return “/admin/suggestion/index”才行啊6.当运行server后发现提示“无法创建bean”或者“无法解析该bean”时，请第一先查看service层的@Service注解是否有加？其次观察DAO层的注解是否有加？检查构造方法，尽可能的别用构造方法的初始化，我就报错了好多次7.如果遇到某些难以言表的错误，明明不可能出现，但还是出现了，就clean install，不但是全局的，全局可能不起作用，而应该深入每一个小模块，逐个的clean install8.如何制造当修改或新增成功后返回主页面的效果呢？这个是无法在controller中实现，而应该在先把成功信息传给前台js，然后js判断是成功信息，就重新发送一次请求给controller,让页面回到主页面。9.想批量删除元素吗？首先要解决多选后，怎么向controller传递id集合的问题？那就是先var array[]；然后再for循环遍历并且赋值——array.push(data[i].id),最后通过$post（“url”，{‘arr’:arr.join(‘,’))}）,最后再controller中写明传参（Long[] ids）即可10.当点击按钮时，会弹出一个可输入的框————如登录注册回复详情等等功能————这个框除非提交否则不会自动消失，怎么实现这个框呢？msgBox.exWindow.open({title: ‘回复’,url: path + ‘/admin/message/online/toPage/reply?id=’ + data.id,width: ‘600px’,height: ‘370px’,close: function (result) {if (result) {$form.submit();}}});11.想通过form表单类让前台ajax传给后台的数据项，一一自动写入form表单类中的每一个属性中，然而却发现有问题，那就是通过form表单类做中介来传输数据时，前台可以传给后台，然而后台处理完毕后想要跳转到另一页面（使用return “admin/bookManager/findTypeNameToValue”之类的跳转方式）时，却发现跳转失败，并且反而变成后台传给前台这个页面的HTML代码了（如果你在ajax中将返回值打印出来便可知），苦寻思路，终究难解，所以只能放弃form表单类，而改用？占位符的方式逐个传输数据给后台，在形参中一一接受。————————————换种思路：那就是不要直接return路径进行跳转，把返回类型改为Message，当登录成功后，设置SUCCESS_MSG的content为登陆成功，然后将该message返回前台js，当ajax接收到后，进行判断，判断message的type是success还是error，如果是success的话，那么重新发送一次请求，向controller请求跳转到主页，便可以啦。12.如果想要使用username和password进行登录操作，虽然简单，但是不安全，password一般长度为20位，如果只是单纯的从数据库中抽出直接进行比对的话，就容易遇到某些隐藏的错误异常和危险。所以应该进行加密，并且使用散列算法加密，因为散列算法的不可逆过程，致使一旦加密城长字符串的话，便无法再度转换回普通字符串。那么如何进行校验呢？答案就是，应该使用相同的散列加密算法，再次对用户输入的password进行加密运算，然后从数据库中调取原加密字符串，二者进行比对即可。13.当我想要通过对后台返回的page数据进行分页操作时，发现一旦在js中写上这句话”var options = self.pageBar.pageBar(‘options’);”，程序直接不执行了，后面的完全停止运行，我不知道哪里出了错？14.vue.js是一个MVVM框架，它的宗旨是”数据驱动，组件系统”。不同于jquery通过鼠标键盘以及其他写定的方式来操作dom元素，从而达到页面的变化，vue.js正是不同于这一点，它是数据驱动的，也就是无需通过鼠标键盘来操作来dom元素，而是通过model层（数据存放处）判断数据是否发生了变化，一旦有变化，立刻通过ViewModel这个黑盒子，更改view层的效果实现，反过来，如果view层监听到了某些点击/时间等等事件的发生时，也会通过ViewModel层这个黑盒子，去进一步修改model的元素。15.由此可知，在vue.js有一个数据绑定叫”v-model”,这个标签表示随时监听这个div中的值（比如在input中放置这个标签），一旦发现这个值改变，于是直接修改model层的数值，从而让有使用到这个model元素的所有dom元素全体改变数值。16.vue.js的思路结构是：MVVM框架，于是我们发现，一个完整的vue.js程序，就必须要有三个组件，即model、view和viewModel这三个。一般而言，view写在html页面的正体即body中（也可添加一些v-if/v-for等等标签，但是这些标签依旧属于view层）,而model一般是存储数据的地方，这个model可以单独写，那么就应该写成var elemet = { message ： “hello world”}这种弱类型对象形式。不过还有另一种写法，那就是将model放在viewModel层中。不同于model是一个弱类型对象（更直接点，应该是类似于c语言中的结构体，只存在字段和对应数值，也可等同于数据表的另一种写法而已），viewModel是一个真正的对象，因为他的意义，是为了连接model层和view层，它要将拿到的model层的数值，传送给view层，所以它也是一个对象，但是功能决然不同。model对象只是存储数据，然而viewModel更类似于java后台中的Service层，它要处理数据和加工，都在这里。因此viewModel的创建方式，变成 new Vue（{el:，data：}）,第一个el是绑定view，第二个data是绑定model，那么就很清楚了，model与viewModel同为对象，那么就不用绑定model，可以直接将model写在data中了。17.vue.js中，index.js负责路由跳转。index.js的功能，就是先创建路由管理员router，然后在路由管理员router里面创建一个routes数组集合，最后再在routes集合中一个一个的写清楚route的单独个体路由。最后使用vue.use(Router);vue中，没有了model的概念，在jsp中，前端与后台有一个调度控制器和ModelAndView作为中间者，后台接受前台请求，处理结构后，直接return 到jsp页面，modelandview便自动带到了目标jsp中。然而vue不同，它的思路是：先路由跳转，跳转后再由新页面发起请求给后台，后台处理后返回一个Map或者Page给该vue，该vue的js中存在一个form名称的“实体类”，map和page都会在这里被解析成一个一个的属性名并自动复制给这个实体类，然后渲染画面。18.在vue的路由中，在同一个routes中，允许存在两个路径不同，但指向结果相同的route，问题是如果两个route一模一样的话会报错的，因此必须将其他的相同的route的component标签去掉，改用重定向标签，即redirect标签，并且内容也要改变。知道什么叫重定向么？那就是再一次发送一次路由请求，请求到那个唯一的、存在component标签的route中。所以，redirect的内容要改变为与那个唯一的route的path相同的存在即可，否则会报错。19.我去，我在springboot里面的实体的Repository中困了半天,总是自动报错然后停止了服务器。有三个问题：1.别写sql语句，请写hql语句，因为sql语句中的*号会报错。2.使用@Query注解时，请一定要在形参传递中加入Pageable。3，请不要让Repository集成JpaRepository，如果继承他的话，应该还要写setBaseRepository这个方法，不然又报错。 pageable这个参数，而不能只有几个搜索的参数啊!!!!这说明一定要看报错说明啊，不然都不知道怎么死的20.我今天被困在JpaRepository好累啊。首先，它的表建立不同于桂林项目，不需要再表字段中加上S_或者I_的前缀，我就这样被坑了好久好久好久！！！第二，JpaRepository没那么神奇，不是想某人说的，会自动根据你在接口写的方法名自动判断你要干什么，这已经是人工智能级别的东西了，别逗，它们都是已经封装好的方法，或者是按照一定的规则编写出来的方法名，这些都是固定的套路，所以不是你想写什么就能写什么的，或者自己写@Query注解的语句也行啊。第三，一定要传递Pageable这个参数，我发现好多地方都有用到啊。21.听说jpa不能多表查询。。。。。我TM今天在干什么22.想看这个页面问过我没？当出现这个问题时，问了同事说，要先跳出来再跳进去里面页面。然而别人不这么写。看了好久，发现应该是这个问题，在index.js的router这个路由管理器中，{path: ‘/devtools/personList/PersonEdit/:id’,name: ‘Practice acx edit’,component: PersonEdit,meta: {requireAuth: false}}每一个路由都是这么写成的，在meta里面有一个requireAuth属性，默认是true的，我们需要将其改为false，就可以跳过。23.在vue中的this.http.get(‘/admin/personInfo/‘ + this.$route.params.id).then(resp =&gt; {…}); 跳转中，有两个问题困住我近乎半天。（1）从列表页怎么将id传给详情页呢？因为两个页面之间是路由跳转，所以无法依托Spring的Java后台来传递，所以要使用this.$route.params。是的，你讲这个this.$route.params在控制台console.log中打印出来，就能发现里面藏了你所要的id（2）明明this.$route.params.id就是我要的id”700538815059591168”,为什么this.http.get(‘/admin/personInfo/‘, this.$route.params.id).then(resp =&gt; {…});这么写时，this.$route.params.id就变成了”0=700538815059591168”,别人这么写都好像没问题，就我卡住了，TM有病啊！！！心血来潮直接把逗号改为加号，结果就好了，TM你在逗我。24.我想搜索三张表，第一张按照主键搜，第二三表用关联id搜索。第一张表用了Service.find(id),然而BaseService没有findOne（Filter）方法，我只能用findAll(Filter,Pageable);这个方法，然而Filter过滤没问题，甚至debug模式显示的sql语句都能搜索正确结果，用这个方法却出现了问题。答案就是，Pageable的问题。我估计Pageable的PageNumber和PageSize都为0，导致虽然有结果，但是无法显示。手动修改Pageable的这两个值即可。用JPA吧，更直接25.使用SpringBoot 中的 Jpa进行删除的时候 ，有三个点要记住，我TM混了半天多才弄懂。–在JPA接口中定义删除方法名时，方法名和sql语句不同，sql语句是”delete from + 表名 + where + 条件”，而方法名是”delete + 实体名 + by + 条件筛选字段（实体类中定义的属性名） + 条件关键字（Equals、like、between等等）”，也就是说删除很不同，如果只是查找搜索的话，无需加上”实体名”和后面的”条件关键字”这两个，但是删除，就要了。–在JPA接口中定义删除方法名时，一定不要忘记加上两个注解，那就是@Modifying 和 @Transactional这两个注解，原因我也不懂，我只知道你不加，TMD系统就会报错。–在JPA接口中定义删除方法名时，删除的返回值是什么？我一开始是使用实体类来接收返回值的，问题是直接报错了，报了个错误说：Integer无法转换为PersonGfInfo（这个是我定义的实体类，也就是返回值），这说明什么？说明执行完delete语句后返回的值，就是一个数值，所以你在定义方法的时候，返回值要写成int型。26.vue怎么使用多选框进行修改和删除呢？1.先给每一个template的循环item添加一个多选框按钮，设置每一个框的value值为id或者其他不重复数值2.让每一个多选框绑定一个全局的数据变量，如v-model=”ids”,3.这样一旦选中一个多选框，ids这个全局数组变量就会自动添加或减少一个value值4.var length = $(“input[type=’checkbox’]:checked”).length;通过这句话，可以获取选中多选框的数量。5.如果想要进行删除操作，则需要向后台传递数组。那么注意，序列化ids的值，只是序列化，序列化后的结果，不是数组，而是表单，你在controller的接受参数只有一个(Long[] ids)，这里实质上是只有一个接收参数，这是数组不是表单，因此你需要在js中将ids转化为数组。怎么转化呢？6.for循环，遍历ids，将每一个ids中的值逐个取出，在后面加上”，”逗号使之连接起来，如此形成一个数组，再向后台传递。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>凯通科技</tag>
      </tags>
  </entry>
</search>
