<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>书到用时方恨少———java Frame之Mybatis的二级缓存</title>
    <url>/2020/03/02/%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94java-Frame%E4%B9%8BMybatis%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 15:11:06 GMT+0800 (GMT+08:00) --><p>一次知识系统的查漏补缺。</p><a id="more"></a><h3 id="Mybatis一级缓存"><a href="#Mybatis一级缓存" class="headerlink" title="Mybatis一级缓存"></a>Mybatis一级缓存</h3><h4 id="从事务说起"><a href="#从事务说起" class="headerlink" title="从事务说起"></a>从事务说起</h4><p>事务是指程序的一次行为，这种行为不同于普通的方法，它要么一次成功，要么失败回到开始执行之前，不存在执行一半的情况。即不成功便成仁。</p><p>举例 ： 张三和李四 进行 转账的操作</p><p>张三向转账李四 1000元 张三余额-1000元 李四余额+1000元</p><p>不应该出现的是 在转账过程中由于一些意外，使张三的余额减去了1000元， 而李四并没有收到这笔钱。 使用事务来进行管理。 必须一起成功或者一起失败。</p><h5 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h5><blockquote><ul><li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul></blockquote><h4 id="从缓存说起"><a href="#从缓存说起" class="headerlink" title="从缓存说起"></a>从缓存说起</h4><p>众所周知，数据库如mysql是存在缓存的，即如果一个sql语句执行的时候，默认是先从缓存里面搜索的，在缓存里，sql语句曾经搜索过的数据，是以键值对的形式存在的。一旦这个sql语句在缓存命中了这个键值对，那么就返回里面的内容给客户端。</p><p>缓存可以提高我们的搜索速度，但也有弊端，以至于很多人宁愿不适用缓存。</p><p>因为有了缓存，就出现了几个问题：脏读、幻读和不可重复读。</p><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p><img src="/2020/03/02/书到用时方恨少———java-Frame之Mybatis的二级缓存/zangdu.jpg"></p><p>为什么会出现脏读？因为当我们第一次搜索数据库时，那么便产生了缓存。此时会话2发起了更新操作。但是update和commit还不太一样。update是先更新缓存里面，再把缓存的数据commit到数据库中，完全更改数据库的硬盘文件内容。只要还没commit，我们就可以rollback。</p><p>那么会话2已经update了缓存的内容但还没更新到数据库硬盘文件中，此时会话1执行了相同的sql语句，根据执行必先搜索缓存原理，此时会话1去搜索缓存，然而不幸的是，会话1遇见的事已经被会话2update过的数据。但问题在于，如果会话2感觉“嗯。。不合适，我还是回滚吧”，那会话1拿到的就是错误的、临时的、无效的数据——脏数据。这个过程就是脏读。</p><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p><img src="/2020/03/02/书到用时方恨少———java-Frame之Mybatis的二级缓存/huandu.jpg"></p><p>为什么会出现幻读？首先会话1搜索了一次数据库，产生了缓存。第二次会话2插入了一条数据，数据库数据完成了更新。问题是缓存还在。这里有两种处理办法，同时也是一个小问题</p><p><strong>更新数据时，是先删除缓存再更新DB，还是先更新DB再删除缓存？</strong></p><ul><li><p>先删除缓存，再更新数据库文件。</p><p>这一种会出现脏读。假如两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p></li><li><p>先更新数据库文件，再删除缓存。即在commit的同时删除了缓存。</p><p>第二种不会出现脏数据。但会出现一致性问题。如上图，会话1前后两次查询，因为会话2删除了缓存，所以两次查询操作都是从数据库中检索的。此时二次数据不一致，这就是幻读。</p><p>然而这种似乎是普遍使用的方法，因为出现一致性的问题，很低很低很低很低。</p><p>以上图为例。会话1查询数据，在还没写入缓存时，会话2就已经comimit，然后会话1再写入内存中。要出现这种情况，首先要两个会话事物并发执行，其次要“写操作”快于“读操作的写缓存操作”，这个概率太低了，众所周知，查询操作中，查询的过程是最耗时间的，但是查完数据了，剩下的时间非常短短短。所以第二种情况概率低。</p></li></ul><h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>什么是不可重复读？原理同幻读。</p><p><img src="/2020/03/02/书到用时方恨少———java-Frame之Mybatis的二级缓存/norepeat.jpg"></p><p>即上面的第二种情况：先更新数据库文件，再删除缓存。即在commit的同时删除了缓存。导致会话1前后两次查询的结果，出现了不一致。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在mysql中存在一种机制，叫做隔离级别。一共有四种，他们可以最大程度的避免脏读、幻读、不可重复读的发生几率。</p><p><img src="/2020/03/02/书到用时方恨少———java-Frame之Mybatis的二级缓存/geli.jpg"></p><ul><li><p>未授权读取，也称读未提交（Read Uncommitted）</p><blockquote><p>我们定义一个“锁”，允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。</p></blockquote><p>也就是，A事物想更新数据，那么A先拿到一个“排他写锁”，然后才继续更新数据。而B事务来了，但是B此时无法拿到这个锁，于是只能等待。在B等待的同时，他是可以去读取数据的，只是不能更新而已。</p><p>如果学过操作系统的线程同步机制，可能会比较容易理解。</p></li><li><p>授权读取，也称为读提交（Read Committed）</p><blockquote><p>我们定义两个“锁”，允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。</p></blockquote></li><li><p>可重复读取（Repeatable Read）</p><blockquote><p>可重复读取（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。</p></blockquote></li><li><p>序列化（Serializable）</p><blockquote><p>序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。</p></blockquote></li></ul><p>我们其实可以发现，从最松的读未提交，到最严格的序列化，其过程是通过允许和不允许并发机制的产生来实现的。也就是说，mysql认为如果你们这些事务不要并发操作，而是一个一个串行这该方便多少啊。</p><p>但是显然，就如同java里面的hashmap和hashtable一样，一个不同步一个同步，最后不还是把具有同步机制的hashtable给弃用了。为什么？因为为了保证线程安全，就必须加上一个同步锁，那样每个线程在执行的时候，就必须先获取锁，获取不到就只能回到阻塞队列里面，速度慢了很多，这才把hashtable抛弃了。</p><p>同理，最严格的，对数据库的性能也是影响最大的。</p><p>因此，如果我们对数据库的操作，是以大量的查询为主，而不是以更新为主，那么我们就可以使用mysql的缓存机制，进而大大优化查询速度了。</p><h4 id="一级缓存总结"><a href="#一级缓存总结" class="headerlink" title="一级缓存总结"></a>一级缓存总结</h4><p>一级缓存跟上面的缓存机制一直，一个图以概括。</p><p><img src="/2020/03/02/书到用时方恨少———java-Frame之Mybatis的二级缓存/sql.jpg"></p><p>一级缓存的生命周期与mysql缓存一致。</p><p>一级缓存的底层设计，是一个可以扩容的hashmap，这也侧面说明了，缓存是以键值对的形式存在的，每次都缓存搜索的过程，就是一次搜索键命中的过程。</p><p>而在mybatis中，一级缓存的作用范围，与一个事务的范围一致。这是为了防止脏读，即一个事务拥有一个一级缓存，互不干扰。</p><p>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构用于存储缓存数据。不同的sqlSession之间的缓存数据区域是互相不影响的。也就是他只能作用在同一个sqlSession中，不同的sqlSession中的缓存是互相不能读取的。</p><p>那是不是一级缓存就一定不会脏读呢？不是的，因为如果mybatis出现在同步并发的系统里，还是会出现脏读问题的。</p><h3 id="Mybatis二级缓存"><a href="#Mybatis二级缓存" class="headerlink" title="Mybatis二级缓存"></a>Mybatis二级缓存</h3><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>什么 SqlSesstion？Sqlsession对应着一次数据库会话。由于数据库会话不是永久的，因此Sqlsession的生命周期也不应该是永久的，相反，在你每次访问数据库时都需要创建它（当然并不是说在Sqlsession里只能执行一次sql，你可以执行多次，当一旦关闭了Sqlsession就需要重新创建它）。它代表着客户端和服务端的一次通信。</p><h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><p>那么了解二级缓存，首先要知道一级缓存的共享范围。一级缓存的范围在一个会话SqlSession之中，即如果一个会话结束，那么缓存结束并且被清空。避免了脏读。</p><p>但是如果需要多个事务一起共享么？那么就需要用到二级缓存。二级缓存的目的，就是为了实现多个会话的缓存共享，虽然可能会出现脏读，因此二级缓存默认不开启，必须手动开启。</p><p>正因为脏读的原因，所以在sqlsession出现更新数据库的操作后，就必须要先更新数据库并且删除缓存。</p><p>但是二级缓存的底层作用机制还是同一级缓存一直，只不过添加了一个多会话共享的机制。底层依旧是hashmap形式在存储缓存，</p><p>虽然缓存某种程度上能够提升检索速度，但与此相对应的，带来的麻烦也是诸多，许多开发者都建议关闭缓存机制，将mybatis作为一个单纯的orm框架使用。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>书到用时方恨少</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>书到用时方恨少———javaSE之static</title>
    <url>/2020/03/02/%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8Bstatic/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><p>static的含义以及一系列特殊的运用方法，比如为什么用类就可以调用？为什么多个对象可以共享一个static变量或方法，这都要从jvm的加载方式说起。</p><a id="more"></a><h4 id="从static的底层加载方式说起"><a href="#从static的底层加载方式说起" class="headerlink" title="从static的底层加载方式说起"></a>从static的底层加载方式说起</h4><p>我们在IDE里面创建一个java项目，然后定义一个包创建一个类，这个类里面写了一个静态方法。在我们点击运行按钮的时候，这个项目经历了如下几个步骤：</p><ul><li>编译，形成*.class字节码文件。字节码文件 = 类结构信息 + 程序变量常量信息 + 程序中的方法信息</li><li>加载，将*.class文件加载进JVM的特定区域</li><li>运行，首先为静态类和静态方法分配内存，然后在运行程序的时候，当执行到new对象的操作时，新创建的对象才被分配内存。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1727685-6505748bc1ef41ff.png"></p><p>从这里可以发现，静态方法和静态变量的存在，是当程序开始运行的时候，甚至是main方法都还没有运行的时候，静态变量和静态方法就已经被放在了方法区中。</p><p><img src="https://raw.githubusercontent.com/FEFJay/markdown_pic/branch1/java_memory_construction.png">然后随着main方法的执行，程序才开始为其他的类的创建分配内存。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//print something;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//print something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么静态方法是属于类的，为什么类可以直接用A-aa-这种方式来调用？"><a href="#为什么静态方法是属于类的，为什么类可以直接用A-aa-这种方式来调用？" class="headerlink" title="为什么静态方法是属于类的，为什么类可以直接用A.aa()这种方式来调用？"></a>为什么静态方法是属于类的，为什么类可以直接用A.aa()这种方式来调用？</h4><p>在上面的程序中，当main方法开始执行之前，A里面的aa()方法就已经被放在了方法区中了，而此时A的实例化对象a还未出现。</p><p>所以很清楚的，静态方法它是不属于对象的，如果属于对象，就不会在A实例化前静aa()就已经被创建。所以静态方法不是对象的，是类的。</p><p>一个具有静态方法和静态变量的类，静态方法和静态变量总是先于对象的创建而产生。在对象尚未实例化，静态方法和静态变量就已经躺在了内存中的方法区。</p><h4 id="为什么静态方法里面只能调用静态方法，而不能调用非静态方法？"><a href="#为什么静态方法里面只能调用静态方法，而不能调用非静态方法？" class="headerlink" title="为什么静态方法里面只能调用静态方法，而不能调用非静态方法？"></a>为什么静态方法里面只能调用静态方法，而不能调用非静态方法？</h4><p>答案也是基于上面的那个static加载机制。</p><p>试想，静态方法先于对象而存在，而 非静态方法（下称动态方法）是随着对象的创建，才正式创建并且常驻内存中。</p><p>如果静态方法能够调用动态方法，那就会有一种情况产生：在静态方法里面调用了尚未创建的对象里的动态方法，就如上面的程序中:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    bb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aa()是存在的，但bb尚未存在，程序直接报错。</p><p>为了防止这种情况的出现，java设置了一种机制，那就是在编译阶段就去检测这种情况的产生。一旦有静态方法调用非静态方法，直接报错。</p><h4 id="静态方法和静态变量能被子类继承么？"><a href="#静态方法和静态变量能被子类继承么？" class="headerlink" title="静态方法和静态变量能被子类继承么？"></a>静态方法和静态变量能被子类继承么？</h4><p>答案是可以的，因为继承的本质，其实就是从父类那儿继承一切属性和一切方法，只不过有一些是隐形继承、一些是显性继承。</p><p>显然，私有方法和私有变量以及静态方法都是这种隐形继承。他们可以被子类继承，但无法被复写。这些静态方法和静态变量对于子类而言是不可见的。</p><p>或者我们这么理解，因为静态方法和静态变量是属于类的，如果子类继承了父类的静态方法，那么一个静态方法就属于了两个类。在我个人而言，这样的static，就失去了仅限于自身类的对象共享一个方法和一个属性的性质。</p><p>是的static于我而言，说是静态，其实我个人理解为共享。</p><p>多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。</p><h4 id="静态方法和静态变量在对象实例化时，有什么不一样么？"><a href="#静态方法和静态变量在对象实例化时，有什么不一样么？" class="headerlink" title="静态方法和静态变量在对象实例化时，有什么不一样么？"></a>静态方法和静态变量在对象实例化时，有什么不一样么？</h4><p>答案其实也在静态方法和静态变量的加载机制中。</p><p>因为动态方法和普通变量，它是属于对象的，也就是说，假设我们把上面的A类给实例化100次，那么这100个A类的对象，就各自拥有一套自己的动态方法和普通变量，无法沟通。</p><p>但是在实例化100次之后，即便他们都各自有一套方法和变量，但是对于100个对象而言，静态方法和静态变量只有一个。100个对象必须通过静态方法和静态变量直接通信。</p><p>所以，一个类的对象，不论有多少个，静态方法和静态属性，永远只有一套，供所有对象<strong>共享调用</strong>。</p><h4 id="那么对象能调用静态方法么？类的子类呢？"><a href="#那么对象能调用静态方法么？类的子类呢？" class="headerlink" title="那么对象能调用静态方法么？类的子类呢？"></a>那么对象能调用静态方法么？类的子类呢？</h4><p>对象是可以直接调用静态方法的，因为静态方法的调用有三种方式：</p><ul><li>new A().aa(); //不推荐使用这种在对象中调用静态方法的</li><li><strong>A.aa(); // 推荐</strong></li><li>aa(); // 仅限于在A类里面自己调用自己的静态方法，才可以省略去前面的类名。</li></ul><p>如果是类的子类，可以直接用父类的类名再去调用静态方法,例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    A.aa();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用A-aa-这种方式，能跨包访问静态变量么？"><a href="#用A-aa-这种方式，能跨包访问静态变量么？" class="headerlink" title="用A.aa()这种方式，能跨包访问静态变量么？"></a>用A.aa()这种方式，能跨包访问静态变量么？</h4><p>答案是，必须先引用包，才能使用类名.静态方法（）。</p><h4 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h4><p>希望能够对你理解static有所帮助。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>书到用时方恨少</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>书到用时方恨少———javaSE之线程</title>
    <url>/2020/03/02/%E4%B9%A6%E5%88%B0%E7%94%A8%E6%97%B6%E6%96%B9%E6%81%A8%E5%B0%91%E2%80%94%E2%80%94%E2%80%94javaSE%E4%B9%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><p>如果我们从例题入手，应该能够更加迅速了解线程的机制和原理</p><p>快速复习同步机制、多线程、线程通信，唤醒沉睡等等。</p><p>同时练习一道普通题，和来自三七互娱和搜狐的两道校招题。</p><a id="more"></a><h4 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h4><h5 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h5><p>java是一种实现多线程的语言。实际上如今大多数语言都支持了多线程。而多线程的原理，这个已经是属于操作系统的范畴了。有机会我再去整理一下操作系统的相关知识框架。</p><p>简单的说，因为我们如今的电脑一般都有多处理器。也就是说有多个CPU。但是在以前，电脑一般只有单个CPU，过去所有的程序都是CPU按照时间片轮转法（还有其他方法，这个是主要的），将CPU分别分配给其他进程轮流使用，每个进程只能使用很短的一个时间片，但因为cpu速度很快，作为用户的我们，其实感受打不到底层的进程切换，在我们眼中，cpu在同时放着音乐，同时处理着文档，也同时浏览着我当前在这个网页。</p><p>但是进程有一个缺点，那就是进程本身是占据资源的。当然运行进程，那么进程就必须持有资源。但是坏也坏在资源。因为进程带有了资源，导致cpu在每个时间片轮转的时候，要先剥夺进程的内存资源等等，导致切换进程的开销很大。所以引出了多线程。</p><p>多线程在当今的操作系统已经取代了进程在运行，一个进程可以分为多个线程，线程一般是不占据资源的，而正因为不占有资源，所以cpu在切换线程的时候，除非是切换到其他进程的线程，否则只要在当前进程中轮换，cpu可以做到开销很小的去切换线程。</p><p>假设一个进程被切分为10个小线程，这10个小线程去抢占一个具有10个cpu的电脑，那么显然，原本一个cpu只执行一个进程，如今10个cpu都为一个进程服务，速度提升了10倍。</p><p>以上为背景。</p><h5 id="java实现线程的方式："><a href="#java实现线程的方式：" class="headerlink" title="java实现线程的方式："></a>java实现线程的方式：</h5><p>有两种方式可以实现线程</p><ul><li>让一个类继承Threawd类</li><li>让一个类去实现Runnable接口</li></ul><p>第一种已经渐渐的淘汰了，目前主要推荐使用第二种。原因也很简单，继承只能单继承，但实现，可以多接口实现。极大的扩展了功能。</p><p>而不管是哪一种实现方式，都必须重写run()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// overwrite</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//overwrite</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承Thread</span></span><br><span class="line">A a = <span class="keyword">new</span> A(<span class="string">"thread name"</span>);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Runnable</span></span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">new</span> Thread(b,<span class="string">"thread name"</span>).start();</span><br></pre></td></tr></table></figure><h5 id="谨记"><a href="#谨记" class="headerlink" title="谨记"></a>谨记</h5><p>一旦线程调用了start方法，就会自动去调用复写了的run方法。但是不能直接去调用run方法，否则就不算多线程了，而只是一个普通的方法调用。</p><h5 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h5><p>在多CPU的环境下，多个线程共同去争夺cpu资源，那么就会产生异步性，这是操作系统的特性之一，也就是说，在两个不同的时间不同地点，同一个程序执行，可能会得到两个不同的结果。</p><p>这是难以接受的，因为程序失去了以往的唯一性和准确性。所以为了保护这种唯一性，创造了通知机制，操作系统中称为PV操作，java中称为 synchronized（请记住这个单词怎么写。。。），我们称为同步锁</p><p>如果synchronized放在了方法体外，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么synchronized的作用范围是整个aa方法，但是作用对象是整个类的所有对象，即如果这个类实例化了100次，那么100对象共有一个锁，他们使用这个锁来通信。</p><p>如果synchronized放在了方法体内，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么synchronized的作用范围是整个aa方法内部的、由ssynchronized括起来的方法内部，作用对象依旧是是整个类的所有对象，即如果这个类实例化了100次，那么100对象共有一个锁，他们还是使用这个锁来通信。</p><p>区别在于，第二种多了一个自定义的锁this。</p><p>我个人理解为 synchronized()括号内是同步锁的标志，我们可以使用this作为多个对象的同步通信机制的媒介。this一般指代当前类的对象。</p><p>一个线程一旦拿到了一个同步锁，那么其他线程如果想要访问这个锁内部的代码，就只能进入阻塞队列中等待，直到那个线程释放了这个锁，那么阻塞队列的线程就被唤醒，重新去争夺锁，然后又是一轮争夺锁阻塞的戏码了。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>我觉得这个图很好很妙。。。。。比如sleep和wait的差别，这里都有提到。</p><p><img src="https://uploadfiles.nowcoder.com/images/20190422/242025553_1555924743926_A141C188264414808176B0950E9E88A8"></p><p>下面直接进入例题：</p><h4 id="两个线程分别打印奇数偶数"><a href="#两个线程分别打印奇数偶数" class="headerlink" title="两个线程分别打印奇数偶数"></a>两个线程分别打印奇数偶数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用JAVA编写程序实现如下功能</span><br><span class="line">    第一个线程A用循环打印从<span class="number">1</span>到<span class="number">100</span>之间的奇数</span><br><span class="line">    第二个线程B用循环打印从<span class="number">1</span>到<span class="number">100</span>之间的偶数。</span><br></pre></td></tr></table></figure><ul><li>显然，第一个线程和第二个线程共有一个变量，1~100中50个属于A，50个属于B。</li><li>每次当a打印完一个奇数，就要先唤醒阻塞队列中的b，然后自身用wait沉睡并释放同步锁</li><li>然后b拿到锁，进入代码去打印一个偶数，打印完就先唤醒阻塞队列中的啊，然后用wait沉睡并释放同步锁</li><li>。。。。。。。。</li></ul><p>原理如此，具体实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread a = <span class="keyword">new</span> Thread(thread,<span class="string">"A"</span>);</span><br><span class="line">		Thread b = <span class="keyword">new</span> Thread(thread,<span class="string">"B"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">        <span class="comment">//这里一直是让我纠结的地方，这么结束线程，总感觉不优雅啊！！！！</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			a.sleep(<span class="number">50</span>);</span><br><span class="line">			b.sleep(<span class="number">50</span>);</span><br><span class="line">			a.interrupt();</span><br><span class="line">			b.interrupt();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断当前能够打印奇数，当true时表示a可以打印，当false时表示b可以打印。</span></span><br><span class="line">	<span class="keyword">boolean</span> flagOfIsPrintOddNumber = <span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span> &amp;&amp; index &lt; <span class="number">100</span>)&#123;</span><br><span class="line">				String currentName = Thread.currentThread().getName();</span><br><span class="line">				<span class="keyword">if</span>(currentName.equals(<span class="string">"A"</span>))&#123;</span><br><span class="line">                    <span class="comment">//为什么两层判断？</span></span><br><span class="line">                    <span class="comment">//上面是判断当前是否是A线程在执行</span></span><br><span class="line">                    <span class="comment">//下面是判断A现在能不能打印，毕竟也有可能存在这样的情况</span></span><br><span class="line">                    <span class="comment">//B先争抢到了同步锁，但B只能打印偶数，我们不能让B打印奇数，所以要记着一层判断</span></span><br><span class="line">					<span class="keyword">if</span>(flagOfIsPrintOddNumber)&#123;</span><br><span class="line">						System.out.println(++ index);</span><br><span class="line">						flagOfIsPrintOddNumber = !flagOfIsPrintOddNumber;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//先唤醒，再沉睡，不要搞混，不然两个都沉睡，没法运行</span></span><br><span class="line">						<span class="keyword">this</span>.notifyAll();</span><br><span class="line">						<span class="keyword">this</span>.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(!flagOfIsPrintOddNumber)&#123;</span><br><span class="line">						System.out.println(++ index);</span><br><span class="line">						flagOfIsPrintOddNumber = !flagOfIsPrintOddNumber;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">this</span>.notifyAll();</span><br><span class="line">						<span class="keyword">this</span>.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						System.out.println(<span class="string">""</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程打印数字和字母（搜狐）"><a href="#多线程打印数字和字母（搜狐）" class="headerlink" title="多线程打印数字和字母（搜狐）"></a>多线程打印数字和字母（搜狐）</h4><p>题目：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建两个线程，其中一个输出<span class="number">1</span>-<span class="number">52</span>，另外一个输出A-Z。</span><br><span class="line">    输出格式要求：<span class="number">12</span>A <span class="number">34</span>B <span class="number">56</span>C <span class="number">78</span>D ...</span><br></pre></td></tr></table></figure><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、线程1打印1-52的数字</span><br><span class="line">2、线程2打印26个字母</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每打印两个数字后打印一个字母，直到最终所有数字和字母都打印完成</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread a = <span class="keyword">new</span> Thread(thread, <span class="string">"index"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		Thread b = <span class="keyword">new</span> Thread(thread, <span class="string">"char"</span>);</span><br><span class="line">		b.start();</span><br><span class="line">        <span class="comment">//这是我看过的，能够生效的唯一让runnable线程结束的方式了</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            a.sleep(<span class="number">50</span>);</span><br><span class="line">            a.interrupt();</span><br><span class="line">            b.sleep(<span class="number">50</span>);</span><br><span class="line">            b.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 因为两个线程要相互唤醒和沉睡，所以必然有一个共同的锁给两个线程使用</span></span><br><span class="line">	<span class="comment">// 既然一个共同的锁，说明不能创建两个线程类，必须只有一个线程类，不然就会产生两个不同的锁。而两个不同的锁，是无法交流的。</span></span><br><span class="line">	<span class="comment">// 同时，共享变量必须都是static</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> charactor = <span class="string">'A'</span>;</span><br><span class="line">	<span class="comment">// flag的意义，是为了判断当前进程应不应该打印数字。当前可能是字符线程抢占执行到这里，但是字符刚刚已经打印了一次，这时候不应该再打印了</span></span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (x++ &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				String nowRun = Thread.currentThread().getName();</span><br><span class="line">				<span class="keyword">if</span> (nowRun.equals(<span class="string">"index"</span>)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">						System.out.print(++index + <span class="string">""</span> + ++index);</span><br><span class="line">						flag = !flag;</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="comment">//不管能不能打印这个字符，你都要唤醒再沉睡，让另一个执行。</span></span><br><span class="line">                    <span class="comment">//所以trycatch的唤醒沉睡，要写在flag的if判断之外</span></span><br><span class="line">					<span class="keyword">try</span> &#123;<span class="comment">// 记住，唤醒要在沉睡之前。</span></span><br><span class="line">							<span class="comment">// 因为第一个进程已经沉睡了，第二个如果不先把第一个唤醒在沉睡，两个就都会陷入沉睡状态</span></span><br><span class="line">						<span class="keyword">this</span>.notifyAll();</span><br><span class="line">						<span class="keyword">this</span>.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (nowRun.equals(<span class="string">"char"</span>)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">						System.out.print(charactor++ + <span class="string">" "</span>);</span><br><span class="line">						flag = !flag;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;<span class="comment">// 记住，唤醒要在沉睡之前。</span></span><br><span class="line">							<span class="comment">// 因为第一个进程已经沉睡了，第二个如果不先把第一个唤醒在沉睡，两个就都会陷入沉睡状态</span></span><br><span class="line">						<span class="keyword">this</span>.notifyAll();</span><br><span class="line">						<span class="keyword">this</span>.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						System.out.println(<span class="string">""</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计两个死锁着的线程（三七互娱）"><a href="#设计两个死锁着的线程（三七互娱）" class="headerlink" title="设计两个死锁着的线程（三七互娱）"></a>设计两个死锁着的线程（三七互娱）</h4><p>这里要用到操作系统的死锁的定义——所有进程持有资源，并且请求其他进程所持有的资源。相互等待，造成死锁。</p><p>但是我已经不想打字了，好累。。。</p><p>有空再更，有想法的，欢迎交流。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>书到用时方恨少</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>华为2016校园招聘上机笔试题-----OJ系统的坑</title>
    <url>/2020/03/01/%E5%8D%8E%E4%B8%BA2016%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AF%95%E9%A2%98-OJ%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><p>校招一共三道编程题。思路很容易想到，但是在面对细节实现时，终究还是感觉自己要更加努力。有一些小细节把我卡住了好久。</p><p>另外最让我抓狂的，便是牛客网系统的输入问题，像第一题总是提示输入为空。而第二题，答案都是一摸一样，竟然还说我输出不一致。。。</p><a id="more"></a><h4 id="Qustion-1-最高分是多少"><a href="#Qustion-1-最高分是多少" class="headerlink" title="Qustion 1 : 最高分是多少"></a>Qustion 1 : 最高分是多少</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩.</span><br></pre></td></tr></table></figure><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包括多组测试数据。</span><br><span class="line">每组输入第一行是两个正整数N和M（0 &lt; N &lt;= 30000,0 &lt; M &lt; 5000）,分别代表学生的数目和操作的数目。</span><br><span class="line">学生ID编号从1编到N。</span><br><span class="line">第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩</span><br><span class="line">接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为&apos;Q&apos;的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少</span><br><span class="line">当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每一次询问操作，在一行里面输出最高成绩.</span><br></pre></td></tr></table></figure><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2 3 4 5</span><br><span class="line">Q 1 5</span><br><span class="line">U 3 6</span><br><span class="line">Q 3 4</span><br><span class="line">Q 4 5</span><br><span class="line">U 4 5</span><br><span class="line">U 2 9</span><br><span class="line">Q 1 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>Answer 1:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> N = input.nextInt();</span><br><span class="line"><span class="keyword">int</span> M = input.nextInt();</span><br><span class="line"><span class="comment">//为了使学号ID和个人成绩一一对应，不想要那种减一加一那种，所以数组大了一个。</span></span><br><span class="line"><span class="keyword">int</span>[] score = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> scoreInputIndex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> operationInputIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(input.hasNextInt() &amp;&amp; scoreInputIndex &lt;= N)&#123;</span><br><span class="line">    score[scoreInputIndex] = input.nextInt();</span><br><span class="line">    scoreInputIndex ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(input.hasNext())&#123;</span><br><span class="line">    String C = input.next();</span><br><span class="line">    <span class="keyword">int</span> num1 = input.nextInt();</span><br><span class="line">    <span class="keyword">int</span> num2 = input.nextInt();</span><br><span class="line">    <span class="comment">//进行更新查询操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个代码在牛客网提交的时候，是显示输入为空的，但是本地运行是能够正确出结果的，头都要秃了，然而我还是找不到问题所在。</p><p>知道在答案区看到了别人写的，然后结合我自己的，终于通过了所有测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in); 		</span><br><span class="line"><span class="keyword">while</span>(input.hasNext())&#123;</span><br><span class="line">      	<span class="keyword">int</span> N = input.nextInt();</span><br><span class="line">          <span class="keyword">int</span> M = input.nextInt();</span><br><span class="line">          <span class="keyword">int</span>[] score = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">int</span> scoreInputIndex = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> operationInputIndex = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; input.hasNext() &amp;&amp; x &lt;= N; x ++)&#123;</span><br><span class="line">          	score[scoreInputIndex ++] = input.nextInt();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; input.hasNext() &amp;&amp; x &lt; M; x ++)&#123;</span><br><span class="line">          	String C = input.next();</span><br><span class="line">              <span class="keyword">int</span> num1 = input.nextInt();</span><br><span class="line">              <span class="keyword">int</span> num2 = input.nextInt();</span><br><span class="line">              count(C,num1,num2,score);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>经过上网查证，我自己是这么理解的不知道对不对。。。</p><p>首先，OJ或者牛客网这种网站，在测试程序时，是一次性放入许多组数据的，我们自己测试的时候是一组一组的放进去，而OJ似乎是一次性放入的。这就是导致，如果在OJ有大量数据输入，我们只能用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	<span class="keyword">while</span>(input.hasNext()) </span><br><span class="line">        或者</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; input.hasNext(); x ++)</span><br></pre></td></tr></table></figure><p>这两种输入之一。</p><p>但是那样的话，我的第一种方法也应该是可以的呀。后来又看到了一篇文章，说的是next()和nextLine()的差别</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//www.ihewro.com/archives/910/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nextInt()、nextFloat()之类函数与next()特性一致。</span><br><span class="line"></span><br><span class="line">    next() 必须先进行有效输入（不包括结束符号的字符）才能结束输入（否则一直是等待输入的状态），然后再使用结束符号结束当前输入（回车、换行、TAB、空格的任一种）</span><br><span class="line">    nextLine()：就没有上面约束了，能接收任何字符，结束符号只有回车一个，所以可以输入含有空格的字符串。</span><br></pre></td></tr></table></figure><p>而在OJ中，当有多组测试用例一同输入时，以EOF结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">多组数据输入，不确定组数，以EOF结束。</span><br></pre></td></tr></table></figure><p>然而我还是不清楚，我的第一种输入和第二种输入，到底有什么差别。。。。。</p><p>附第一题的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(input.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> N = input.nextInt();</span><br><span class="line">            <span class="keyword">int</span> M = input.nextInt();</span><br><span class="line">            <span class="comment">//为了使学号ID和个人成绩一一对应，不想要那种减一加一那种，所以数组大了一个。</span></span><br><span class="line">            <span class="keyword">int</span>[] score = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> scoreInputIndex = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> operationInputIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; input.hasNext() &amp;&amp; x &lt;= N; x ++)&#123;</span><br><span class="line">                score[scoreInputIndex ++] = input.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; input.hasNext() &amp;&amp; x &lt; M; x ++)&#123;</span><br><span class="line">                String C = input.next();</span><br><span class="line">                <span class="keyword">int</span> num1 = input.nextInt();</span><br><span class="line">                <span class="keyword">int</span> num2 = input.nextInt();</span><br><span class="line">                count(C,num1,num2,score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] count(String C,<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span>[] score)&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (C) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Q"</span>:</span><br><span class="line">            result = max(score, num1, num2);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"U"</span>:</span><br><span class="line">            score[num1] = num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] score,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = start;</span><br><span class="line">            start = end;</span><br><span class="line">            end = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = start;x &lt;= end; x ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result &lt; score[x])&#123;</span><br><span class="line">                result = score[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Qustion2-简单错误记录"><a href="#Qustion2-简单错误记录" class="headerlink" title="Qustion2: 简单错误记录"></a>Qustion2: 简单错误记录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。 </span><br><span class="line">  处理:</span><br><span class="line">  <span class="number">1</span>.记录最多<span class="number">8</span>条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并)</span><br><span class="line">  <span class="number">2</span>.超过<span class="number">16</span>个字符的文件名称，只记录文件的最后有效<span class="number">16</span>个字符；(如果文件名不同，而只是文件名的后<span class="number">16</span>个字符和行号相同，也不要合并)</span><br><span class="line">  <span class="number">3</span>.输入的文件可能带路径，记录文件名称不能带路径</span><br></pre></td></tr></table></figure><h5 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。</span><br><span class="line">    文件路径为windows格式</span><br><span class="line">    如：E:\V1R2\product\fpgadrive.c 1325</span><br></pre></td></tr></table></figure><h5 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将所有的记录统计并将结果输出，格式：文件名代码行数数目，一个空格隔开，如: fpgadrive.c 1325 1 </span><br><span class="line">    结果根据数目从多到少排序，数目相同的情况下，按照输入第一次出现顺序排序。</span><br><span class="line">    如果超过8条记录，则只输出前8条记录.</span><br><span class="line">    如果文件名的长度超过16个字符，则只输出后16个字符</span><br></pre></td></tr></table></figure><h5 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h5><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\V1R2\product\fpgadrive.c 1325</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fpgadrive.c 1325 1</span><br></pre></td></tr></table></figure><p>Answer 2:</p><p>在这道题，就发生了一件让我很崩溃的事情，那就是明明输入输出都一模一样，但就是判我错。</p><p><img src="https://pp.qn.img-space.com/202003/1/fa8de94ca06f584951a30c019371beb9.png?imageView2/2/w/1200/q/75/ignore-error/1/"></p><p>我。。。。我也不知道怎么办，又没有原因。。。</p><p>但查漏补缺才是最重要的，在这道题中，我发现了几个问题：</p><p>1、在input.next()里面，不接受存在空格的字符串，因为在input.next()里面，空格使输入结束的标志之一，详情请看我在第一题的分析，所以因为输入的文件名和行数之间存在空格，必须使用nextLine()，否则就必须分开两次输入，路径名用next()，行号用nextInt() ，当然循环还是用hasNext()。</p><p>2、面对这样的一个输入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E:\V1R2\product\fpgadrive.c <span class="number">1325</span></span><br></pre></td></tr></table></figure><p>我的本意是，首先将整个按空格切分为路径 + 行号的组合，但是忽略了next和nextLine的区别。于是转为路径用next，行号用nextInt()的方法。</p><p>不过呢，这有一个bug。众所周知，在windows系统的c盘里面，有一个文件名为program file，它是我们安装文件的路径。。。。所以，这其实是一个潜在bug。</p><p>先看重点，我们获取了路径，因为我们存储的是文件名，所以理所当然的，我们就对路径做split切分，以反斜杠为准。然而就是这里出了问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用 str.split(<span class="string">"\");是错的。str.split("</span>\\<span class="string">")也是错的。必须使用str.split("</span>\\\\<span class="string">");</span></span><br></pre></td></tr></table></figure><p>3、题目要求最终按照记录数的多少，降序排序。那么在hashmap这里面怎么降序排序？？</p><p>这个是我以前没用过的，直到google一下，才发现，要用比较器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Entry&lt;String, Integer&gt;&gt; list;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里如果是o1.getValue() - o2.getValue()就是升序，下面的是降序</span></span><br><span class="line">		<span class="keyword">return</span> (o2.getValue() - o1.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对hashmap的遍历，基本都是将key放在一个list里面，然后从list拿出来。</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Integer&gt; t : list) &#123;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">8</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	index ++;</span><br><span class="line">	System.out.print(t.getKey() + <span class="string">" "</span> + t.getValue() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、题目要求数目相同的情况下，按照输入第一次出现顺序排序</p><p>这里就要求我们要将hashmap插入时的时间顺序记住。但也正是这里，让我感觉头疼，如果再建一个结构来存储他们的时间，可以是可以，但这代码我自己都看不下去，我总觉得一定有更好的方法，果不其然，我发现了hashMap是不存储插入顺序的，但是hashmap的子类LinkedHashMap会。</p><p>因为linked结构，所以查找会相比于hashmap慢一些，但是技术这种东西，没有好不好，只有适不适合。。</p><p>我觉得，今天就是LinkedHashMap大显身手爆锤hashmap的时候了哈哈哈哈哈哈哈。</p><p>附上第二题代码（谨慎参考，因为虽然与系统答案一致，但是牛客毕竟判我错）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		Map&lt;String, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; inputList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">while</span> (input.hasNext()) &#123;</span><br><span class="line">			String dir = input.next();</span><br><span class="line">			<span class="keyword">int</span> lineNum = input.nextInt();</span><br><span class="line">			String[] fileNames = dir.split(<span class="string">"\\\\"</span>);</span><br><span class="line">			String finalName = fileNames[fileNames.length - <span class="number">1</span>];</span><br><span class="line">			finalName = finalName + <span class="string">" "</span> + lineNum;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(finalName)) &#123;</span><br><span class="line">				<span class="keyword">int</span> value = map.get(finalName);</span><br><span class="line">				map.put(lengthMoreSixteen(finalName), ++value);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map.put(lengthMoreSixteen(finalName), <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line">		Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> (o2.getValue() - o1.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;String, Integer&gt; t : list) &#123;</span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">8</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			index ++;</span><br><span class="line">			System.out.print(t.getKey() + <span class="string">" "</span> + t.getValue() + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> String <span class="title">lengthMoreSixteen</span><span class="params">(String finalName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (finalName.length() &gt; <span class="number">21</span>) &#123;</span><br><span class="line">			finalName = finalName.substring(finalName.length() - <span class="number">21</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> finalName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question3：扑克牌大小"><a href="#Question3：扑克牌大小" class="headerlink" title="Question3：扑克牌大小"></a>Question3：扑克牌大小</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">扑克牌游戏大家应该都比较熟悉了，一副牌由<span class="number">54</span>张组成，含<span class="number">3</span>~A，<span class="number">2</span>各<span class="number">4</span>张，小王<span class="number">1</span>张，大王<span class="number">1</span>张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:) </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> J Q K A <span class="number">2</span> joker JOKER </span><br><span class="line">输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：<span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span>-joker JOKER</span><br><span class="line">请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR</span><br><span class="line">   </span><br><span class="line">   基本规则:</span><br><span class="line">	（<span class="number">1</span>）输入每手牌可能是个子，对子，顺子（连续<span class="number">5</span>张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列；</span><br><span class="line">	（<span class="number">2</span>）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）</span><br><span class="line">	（<span class="number">3</span>）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌；</span><br><span class="line">	（<span class="number">4</span>）输入的两手牌不会出现相等的情况。</span><br><span class="line">       </span><br><span class="line">提示：</span><br><span class="line">（<span class="number">1</span>）除了炸弹和对王之外，其他必须同类型比较。</span><br><span class="line">  	（<span class="number">2</span>）输入已经保证合法性，不用检查输入是否是合法的牌。</span><br><span class="line">	（<span class="number">3</span>）输入的顺子已经经过从小到大排序，因此不用再排序了.</span><br></pre></td></tr></table></figure><h5 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如4 4 4 4-joker JOKER。</span><br></pre></td></tr></table></figure><h5 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出两手牌中较大的那手，不含连接符，扑克牌顺序不变，仍以空格隔开；如果不存在比较关系则输出ERROR。</span><br></pre></td></tr></table></figure><h5 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h5><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4 4 4-joker JOKER</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joker JOKER</span><br></pre></td></tr></table></figure><p>Answer 3:</p><p>第三题我想做，但是。。。</p><p>我看不懂题目。。。我们自己玩扑克，没这么多叫法。。。我要去了解下规则，才能做这道题。。。。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>校招</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>由树的前序和中序遍历，构建二叉树的后序遍历</title>
    <url>/2020/02/29/%E7%94%B1%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><h2 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION:"></a>QUESTION:</h2><p>给定二叉树的前序（GDAFEMHZ）中序遍历（ADEFGHMZ）、输出二叉树的后序遍历</p><p>(剑指offer原题) 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><a id="more"></a><h2 id="ANSWER"><a href="#ANSWER" class="headerlink" title="ANSWER:"></a>ANSWER:</h2><p>在二叉树的构建中，我们首先有了一个前序一个中序。</p><p>如这道题目里面，假设存在</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String preStr = <span class="string">"GDAFEMHZ"</span>;</span><br><span class="line">String midStr = <span class="string">"ADEFGHMZ"</span>;</span><br></pre></td></tr></table></figure><p>这两个，其中preStr是前序输出，midStr是中序输出。</p><p>显然，因为前序必然是从根节点开始的，所以</p><p>1、G必然是根节点。</p><p>在中序遍历中，根节点的存在，必然是将二叉树左右分的存在。即在中序遍历中，左边是他的左节点，右边是他的右节点，所以</p><p>2、ADEF是根节点G的左节点，HMZ是根节点G的右节点。</p><p>由于G存在左节点，而根据中序遍历的定义，显然，根节点G的下一个左节点，成为G左子树中的根节点。</p><p>就如这张图片所显示的</p><p><img src="https://img-blog.csdn.net/20160514151139043"></p><p>在这张图片中，虽然6是根节点，但是2同样可以作为6的整个左子树的根节点，同理，8也可以作为6的整个右子树的根节点。</p><p>从这里我们不难发现，此处出现了一个递归规律，那就是，我们可以类似于树的递归遍历那样，首先从6根节点出发，然后将6.left再一次放入递归函数中，再将6.left.left放入递归函数中，直至6.left.left……..left.left == null，我们就可以return null，使之回到上一级，进入6.left.left……left.right。</p><p>于是乎，树的构建规律便显现出来了，通过递归我们可以构建一棵树。</p><p>然后便是解决各个节点所安放的位置了。我们再回到上面那个图片，从中可以明显看出，该树的前序中序遍历是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序 <span class="number">6</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">中序 <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>其遍历路径，是从6开始，一直向左节点走到尽头0，再去探访尽头的右节点1，探访完，就回去父节点2探访右节点4……以此类推，我们可以发现，这个前序遍历的规律，便是我们上面发现的递归规律。</p><p>于是乎，一个很明显的答案便浮现出来，那就是前序遍历的顺序，正好对应前序建树的路程。</p><p>我们每次先从前序队列里面拿出第一个元素 M，这个元素就是一整棵树中的某一部分子树的根节点。如6是树的根节点，2是6的左子树的根节点，4是2的右子树的根节点。然后我们将中序队列按照 M 切分为两个部分，左部分元素是M节点的左子树，有部分元素是M节点的右子树。例如，我们从前序队列中找到M = 6 ，则我们将中序按照6分为两个部分为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> | <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>显然，0 1 2 4 5 为6 的左节点，8 9 为6 的右节点。</p><p>然后我们令6.left成为递归的下一个节点，于是在新一轮递归中，根节点变为了前序队列中的下一个：2</p><p>紧接着，我们在按照上面的划分，将0 1 2 4 5 以2位中间分为两部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> | <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>其中，0 1 是2 的左节点，4 5 是2 的右节点。</p><p>以此类题，构建一整棵树。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序</span></span><br><span class="line">		String preStr = <span class="string">"GDAFEMHZ"</span>;</span><br><span class="line">        <span class="comment">//中序</span></span><br><span class="line">		String midStr = <span class="string">"ADEFGHMZ"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span>[] pre = preStr.toCharArray();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pre.length; x++)&#123;</span><br><span class="line">			queue.offer(pre[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode(queue.poll());</span><br><span class="line">		construct(root,midStr);</span><br><span class="line">		preOrder(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="comment">//如果结点为空则返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        preOrder(root.left);<span class="comment">//访问左孩子</span></span><br><span class="line">        preOrder(root.right);<span class="comment">//访问右孩子</span></span><br><span class="line">        System.out.print(root.val + <span class="string">" "</span>);<span class="comment">//访问根节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> TreeNode <span class="title">construct</span><span class="params">(TreeNode root,String arr)</span></span>&#123;</span><br><span class="line">		<span class="comment">//根据根节点，将中序遍历的剩余子节点切分为左右两半，若是左边有元素，则该节点存在左孩子，若是右边有元素，则该节点存在右孩子</span></span><br><span class="line">		String[] leftAndRight = arr.split(String.valueOf(root.val));<span class="comment">//经过这个切分，leftAndRight成为一个数组</span></span><br><span class="line">		<span class="keyword">if</span>(leftAndRight.length == <span class="number">0</span>)&#123;<span class="comment">//若是左边为空，说明左孩子已经走到了尽头，往下走不会再有孩子了，应该回退到上一级，看看上一级有没有右孩子</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftAndRight[<span class="number">0</span>].length() == <span class="number">0</span>)&#123;<span class="comment">//若是左边不为空，要判断左边的元素数组个数，当然左边是可以不设置的，但是为了和右边相对称，还是写上吧。</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果左边不为空，且左边的元素不是“”值，则说明必然存在左节点。</span></span><br><span class="line">			<span class="keyword">char</span> rootVal = queue.poll();<span class="comment">//从队列中提取元素，作为当前节点的做孩子节点，并且将左孩子放入递归算法中。</span></span><br><span class="line">			TreeNode left = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">			root.left = left;</span><br><span class="line">			construct(root.left, leftAndRight[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若是左边为空，说明左孩子已经走到了尽头，往下走不会再有孩子了，应该回退到上一级，看看上一级有没有右孩子</span></span><br><span class="line">		<span class="comment">//而且第二个判断条件 || leftAndRight.length == 1，是因为如果leftAndRight的长度只为1，那么其实这个1是左孩子的1，不是右孩子的，说明右孩子还是为空。</span></span><br><span class="line">		<span class="comment">//记住这个判定条件，我在这里卡了很久。</span></span><br><span class="line">		<span class="comment">//超级重要，因为如果不加如这个判定条件，那么程序就会直接执行到添加右节点的语句中，那么就会把HMZ这三个右节点的属性，给错放到根节点的左子树中。不信你试试</span></span><br><span class="line">		<span class="keyword">if</span>(leftAndRight.length == <span class="number">0</span> || leftAndRight.length == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftAndRight[<span class="number">1</span>].length() == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">char</span> rootVal = queue.poll();</span><br><span class="line">			TreeNode right = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">			root.right = right;</span><br><span class="line">			construct(root.right, leftAndRight[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">	<span class="keyword">char</span> val;</span><br><span class="line"></span><br><span class="line">	TreeNode(<span class="keyword">char</span> val) &#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>树</tag>
        <tag>剑指OFFER</tag>
      </tags>
  </entry>
  <entry>
    <title>一个智能问答系统的自然语言处理机制（一）</title>
    <url>/2020/02/29/%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><p>​ 在当前人工智能背景下，计算机视觉、机器学习和自然语言处理等等共同作为人工智能大树的分支而并列共存。</p><p>​ 谈及自然语言，从语言的语法体系出现以来，我们便一直使用词性、主谓宾等等句子结构来分析句子，自然而然的，我们倾向于让计算机使用人类的思维去理解句子，然而经过几十年的探索，我们才不得不承认这个尝试失败了。</p><a id="more"></a><p>​ 如今，已经不会再有计算机科学家再继续坚持使用传统人类的语法规则去让计算机理解语言，而是使用了基于统计语言模型的数学模型，它是所有自然语言处理的基础，并且广泛应用于机器翻译、语音识别、手写输入等。</p><p>​ 自然语言处理是人工智能体系中的一个大分支，它回答了机器是如何使用数学模型来解决中文分词问题，并且尝试让机器去理解这一段话。</p><p>​ 这篇总结，是我基于项目而归纳出的一点心得，后续再整理补充。</p><p>​ 项目代码源于github：<a href="https://github.com/AnchengXu/Spring-Boot-Neo4j-Movies" target="_blank" rel="noopener">https://github.com/AnchengXu/Spring-Boot-Neo4j-Movies</a></p><p>​ 搭建过程源于CSDN：<a href="https://blog.csdn.net/appleyk/article/details/80331997" target="_blank" rel="noopener">https://blog.csdn.net/appleyk/article/details/80331997</a></p><p><img src="https://pic2.zhimg.com/v2-66f210d04b273c6616f00bece467223a_1200x500.jpg"></p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>​ 我们在做自然语言处理时（针对特定主体的，基于检索的模型），首先需要明白一个重点，那就是一个自然文本中，重点永远是名词。这个名词可能是事物（太阳、晋升）、人名（周星驰）、电影名（大话西游）、角色名（总经理）等等，这些名词中，有些是大部分文本处理框架中自带的，而有些是需要自己自定义词典，然后导入到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CustomDictionary.add(word, <span class="string">"nm 0"</span>);</span><br></pre></td></tr></table></figure><p>中的。</p><p>​ 就以电影知识问答系统而言，一个关于电影主题的句子，必然是围绕着一个主体，然后进行着一系列动作的。于是，每一个句子，基本都可以划分为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nr() 的 nm() 分数/简介/演员/评价</span><br></pre></td></tr></table></figure><p>基本也就这个框架了。</p><p>​ 从这个项目中，有一个点我不知道对不对，但是在这个项目中是可以的，那就是自然语言处理中，对文本的角色识别，基本都是对名词的识别，然后针对特定主主题的动词，诸如分数、简介、演员列表、评价等等，这些都应该是自定义词典然后进行文本匹配的。如果是无主题的问答系统，那么自然是一个庞大的工程，但是这是基于检索的特定主题的nlp，所以自定义一个词典，我个人感觉是不难的。</p><p>​ 而且这个项目有个很大的问题，那就是在ModelPrecess.java中，根据spark的贝叶斯分类后，进行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>[] testArray = sentenceToArrays(sentence);</span><br><span class="line">Vector v = Vectors.dense(testArray);</span><br><span class="line"><span class="keyword">double</span> index = nbModel.predict(v);</span><br></pre></td></tr></table></figure><p>预测得到的index，但是这个预测有个很大的问题，因为在这个程序中，对于v向量的描述是人工添加的某些字段组合而成，也就是说，你问的问题，除了名词即角色主体之外，必须包含有vocabulary.txt其中的190个字段，如此必须具备多个字段，这样spark的贝叶斯分类器才能将14个模板问题区分开，</p><h2 id="一、载入190个单词的词汇表"><a href="#一、载入190个单词的词汇表" class="headerlink" title="一、载入190个单词的词汇表"></a>一、载入190个单词的词汇表</h2><p>​ 将那个词汇表载入内存中，我们到时需要将一个问题切分，然后进行遍历，与这个词汇表进行比对，从而了解这个问题到底在说什么。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vocabulary = loadVocabulary();</span><br></pre></td></tr></table></figure><h2 id="二、载入13个归类问题的训练数据问题表"><a href="#二、载入13个归类问题的训练数据问题表" class="headerlink" title="二、载入13个归类问题的训练数据问题表"></a>二、载入13个归类问题的训练数据问题表</h2><p>​ 这是所有问题的最终13个答案，是通过不断评分，最后得出的13个可以被机器理解的问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">questionsPattern = loadQuestionsPattern();</span><br></pre></td></tr></table></figure><h2 id="三、载入所有问题数据"><a href="#三、载入所有问题数据" class="headerlink" title="三、载入所有问题数据"></a>三、载入所有问题数据</h2><p>​ 这是spark训练的13个多个问题回答样式，spark将通过学习，知道哪些问题是回答评分，哪些问题是回答出生日期。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  NaiveBayesModel <span class="title">loadClassifierModel</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="四、创建训练模型"><a href="#四、创建训练模型" class="headerlink" title="四、创建训练模型"></a>四、创建训练模型</h2><h3 id="生成训练器的主体，spark程序对象"><a href="#生成训练器的主体，spark程序对象" class="headerlink" title="生成训练器的主体，spark程序对象"></a>生成训练器的主体，spark程序对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、生成Spark对象</span><br><span class="line">Spark程序是通过SparkContext发布到Spark集群的</span><br><span class="line">Spark程序的运行都是在SparkContext为核心的调度器的指挥下进行的</span><br><span class="line">Spark程序的结束是以SparkContext结束作为结束</span><br><span class="line">JavaSparkContext对象用来创建Spark的核心RDD的</span><br><span class="line">注意：第一个RDD,一定是由SparkContext来创建的</span><br><span class="line"></span><br><span class="line">二、SparkContext的主构造器参数为 SparkConf</span><br><span class="line">SparkConf必须设置appname和master，否则会报错</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"NaiveBayesTest"</span>).setMaster(<span class="string">"local[*]"</span>);</span><br><span class="line">JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br></pre></td></tr></table></figure><h3 id="生成训练集LabelPoint"><a href="#生成训练集LabelPoint" class="headerlink" title="生成训练集LabelPoint"></a>生成训练集LabelPoint</h3><p>​ 定义一个train_list,该变量中，存储13个问题文件一共近100个问题的Labelpoint，而labelpoint是由Vector组成的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;LabeledPoint&gt; train_list = <span class="keyword">new</span> LinkedList&lt;LabeledPoint&gt;();</span><br></pre></td></tr></table></figure><p>​ labelpoint要么是稀疏，要么是密集。将一个问题文件中，如“出生日期.txt”中的10个问题，进行逐个的拆分，每一个问题都要转为double型数组，然后将这个数组转为Vector向量，可以是稀疏性、可以使密集型向量均可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>[] array = sentenceToArrays(sentence);</span><br></pre></td></tr></table></figure><p>​ 紧接着将Vector向量转为labelpoint，因为只有labelpoint才能被spark进行识别并且计算分类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LabeledPoint train_one = <span class="keyword">new</span> LabeledPoint(<span class="number">0.0</span>, Vectors.dense(array));</span><br><span class="line">train_list.add(train_one);</span><br></pre></td></tr></table></figure><p>​ 13个问题文件全部都要这样去载入。</p><h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><p>​ java创建JavaRdd，并将上面的train_list放入javardd中进行训练，得到Spark贝叶斯分类器NaiveBayesModel</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaRDD&lt;LabeledPoint&gt; trainingRDD = sc.parallelize(train_list);</span><br><span class="line">			NaiveBayesModel nb_model = NaiveBayes.train(trainingRDD.rdd());</span><br></pre></td></tr></table></figure><h3 id="缓冲读入"><a href="#缓冲读入" class="headerlink" title="缓冲读入"></a>缓冲读入</h3><p>​ 将自己收集的数据，进行缓冲读入，例如将所有的电影名字放在一个txt文件中，然后用下面这句话进行读入到BufferedReader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(path)));</span><br></pre></td></tr></table></figure><h3 id="放入Hanlp中的自定义字典中"><a href="#放入Hanlp中的自定义字典中" class="headerlink" title="放入Hanlp中的自定义字典中"></a>放入Hanlp中的自定义字典中</h3><p>​ 将从缓冲读入取得br，根据字典的不同或者词性的不同，存入 Hanlp中的类库CustomDictionary中，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String word;</span><br><span class="line"><span class="keyword">while</span> ((word = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 设置电影名词词性 == nm 0</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            CustomDictionary.add(word, <span class="string">"nm 0"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 设置电影类型名词 词性 == ng 0</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            CustomDictionary.add(word, <span class="string">"ng 0"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 设置电影评分数词 词性 == x 0</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            CustomDictionary.add(word, <span class="string">"x 0"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-分析问题，开始问题处理"><a href="#五-分析问题，开始问题处理" class="headerlink" title="五 分析问题，开始问题处理"></a>五 分析问题，开始问题处理</h2><h3 id="对文本进行分词处理，抽象提取"><a href="#对文本进行分词处理，抽象提取" class="headerlink" title="对文本进行分词处理，抽象提取"></a>对文本进行分词处理，抽象提取</h3><p>​ 用hanlp，对一个问题如”吴孟达”，会进行分词，并且进行词汇的抽象分析，比如“吴孟达”，就会被hanlp的人名词典进行辨识，如果在人名词典（可能是日文、或者汉化英文名）找到了，那么在后缀加上nr的nature标识，或者也可以去自定义的人名词典去搜寻，找到了，也可以添加自定义的后缀nature标识。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象句子，利用HanPL分词，将关键字进行词性抽象</span></span><br><span class="line"><span class="comment"> * 先抽象，比如将人名全部改为nr，其主要目的是为了简化句子，只剩下190个关键词进行匹配*/</span><span class="comment">// 句子抽象化</span></span><br><span class="line">		Segment segment = HanLP.newSegment().enableCustomDictionary(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//使用segment将querySentence句子做切分，切分成多个词</span></span><br><span class="line">		List&lt;Term&gt; terms = segment.seg(querySentence);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Term term : terms)</span><br><span class="line"><span class="keyword">if</span> (termStr.contains(<span class="string">"nr"</span>) &amp;&amp; nrCount == <span class="number">0</span>) &#123; <span class="comment">//nr 人名</span></span><br><span class="line">				abstractQuery += <span class="string">"nnt "</span>;</span><br><span class="line">				abstractMap.put(<span class="string">"nnt"</span>, word);</span><br><span class="line">				nrCount++;</span><br></pre></td></tr></table></figure><p>​ 于是，“吴孟达”就变成了“nnt”。</p><h3 id="将拿到的“nnt”与spark训练过的模板比对"><a href="#将拿到的“nnt”与spark训练过的模板比对" class="headerlink" title="将拿到的“nnt”与spark训练过的模板比对"></a>将拿到的“nnt”与spark训练过的模板比对</h3><p>​ 根据概率，拿到相对应的回答模板</p><h2 id="尾、尚未理解的问题"><a href="#尾、尚未理解的问题" class="headerlink" title="尾、尚未理解的问题"></a>尾、尚未理解的问题</h2><h3 id="NativeBayesModel-predict-方法"><a href="#NativeBayesModel-predict-方法" class="headerlink" title="NativeBayesModel.predict()方法"></a>NativeBayesModel.predict()方法</h3><p>​ NativeBayesModel.predict()方法到底是怎么进行归类实现的，浅显的原理大家都懂，毕竟只要说“随着新的数据，能够不断更新旧的概率，使得更可靠”，但是实现怎么做？？？</p><h3 id="NativeBayesModel-predictProbabilities-方法"><a href="#NativeBayesModel-predictProbabilities-方法" class="headerlink" title="NativeBayesModel.predictProbabilities()方法"></a>NativeBayesModel.predictProbabilities()方法</h3><p>​ NativeBayesModel.predictProbabilities()方法这tm概率怎么算的？？？</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>问答系统</tag>
      </tags>
  </entry>
  <entry>
    <title>在链表中判断环的存在</title>
    <url>/2020/02/28/%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A4%E6%96%AD%E7%8E%AF%E7%9A%84%E5%AD%98%E5%9C%A8/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><h2 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h2><p>​ Given a linked list, determine if it has a cycle in it.</p><p>​ 给定一个链表，判断链表中是否有环。</p><p>​ 给出推理验证过程，以及代码实现（JAVA）。</p><a id="more"></a><h2 id="Answer："><a href="#Answer：" class="headerlink" title="Answer："></a>Answer：</h2><p>​ 由反证法证明，在一个有环的链表中</p><p><img src="/2020/02/28/在链表中判断环的存在/copy.png"></p><p>​ 假设有两个人从起点A开始向后走，其中m每次走两步，n每次走一步。显然，在第一次走了之后，m = 2，n = 1，此后，m &gt; n 永远成立。若是这个链表无环，m和n必然无法相会，因为n永远追不上m。</p><p>​ <strong>记住这是前提，也就是说，如果无环，二者在起点之后必然永不相遇。</strong></p><p>​ 但是如果有环，则m在走的快之后，必然会回到m自己走过的路上，这个路可能是n走过的，也可能是n尚未走过的。</p><p>​ 1、如果m经过环到了n的后方，那么不管怎么样走，m和n必然能到达最后两种情况：要么相遇，要么只相差一个节点。</p><p>​ <strong>如果直接相遇，那么就说明违背了前提——无环则永不相遇，有反证法可知，链表存在环。</strong></p><p>​ 如果只相差一个节点，即 n - m = 1，那么下一步，n + 1 = m + 2 ， 于是二者相遇，违背了前提——无环永 不相遇，有反证法可知，链表存在环。</p><p>​ 2、如果m经过环跳转到n的前方，那么不管怎么走，m必然达到这么一种情况：不断在环内行走，直到n走到这个环内，<strong>于是回到了1的情况中，二者必然相遇</strong>。</p><p><img src="https://www.dynamic-zheng.com/images/2019/有环链表.jpg"></p><p>​ 依据这个证明，我们可以写出证明方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCircle</span><span class="params">(Node headNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headNode == <span class="keyword">null</span> || headNode.next() == <span class="keyword">null</span>)&#123;<span class="comment">//头结点为空，或者链表只有首结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node NRunner = headNode.next();</span><br><span class="line">    Node MRunner = headNode.next().next();</span><br><span class="line">    <span class="keyword">while</span>(NRunner.next() != <span class="keyword">null</span> &amp;&amp; MRunner.next() != <span class="keyword">null</span>)&#123;</span><br><span class="line">        NRunner = NRunner.next();</span><br><span class="line">        MRunner = MRunner.next().next();</span><br><span class="line">        <span class="keyword">if</span>(NRunner == MRunner)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得证，以上。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>定期感情清零&lt;CoverBy我要WhatYouNeed&gt;</title>
    <url>/2019/05/25/%E5%AE%9A%E6%9C%9F%E6%84%9F%E6%83%85%E6%B8%85%E9%9B%B6/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><blockquote><p>今天分享一篇日记。</p><p>日记的主人 Pill，是一位几乎没有恋爱经验的女生。她在最近一次“尝试恋爱”之后，记录了自己的全部感受。</p><p>而「定期情感清零」，是她认为必要的步骤。</p><p>日记并不长。</p><p>今天，就不妨试着没有负担地阅读，走进她那变得平和的感情世界里。</p></blockquote><a id="more"></a><center><br><br>2019 年的第一份喜欢，<br><br>像夏天里的第一口冰可乐，<br><br>碳酸饮料式的热烈，<br><br>但消淡的速度也很快。<br><br><br><br>停止喜欢快一个月了。<br><br>我没有再像以前一样，<br><br>花费很多时间去想为什么。<br><br><br><br>我原本以为自己喜欢得热烈，<br><br>但原来也不过如此。<br><br><br><br>我也觉得我应该会难过的，<br><br>但我没有。<br><br>反倒觉得松了一口气，<br><br>因为我不用再因为对方的一句话，<br><br>就轻易地开心或不开心。<br><br><br><br>在这件事上，<br><br>我发现，<br><br>自己面对情感关系时终于成熟了一点：<br><br>不再长久地纠结一段不重要的关系。<br><br><br><br>梁文道在《我执》里写过一段话：<br><br><em>第一次和他吃饭，</em><br><br><em>他看到背后的墙上有只漂亮的碟子，</em><br><br><em>来自罗马一家著名的餐厅。</em><br><br><em>大概是一时兴奋，</em><br><br><em>他冲口而出：</em><br><br><em>“我们以后一定要去那里吃。”</em><br><br><em>后来我一直反复琢磨，</em><br><br><em>他说的，</em><br><br><em>到底是“我”，还是“我们”呢？</em><br><br><em>如果是随兴的话，</em><br><br><em>“我”和“我们”又有什么分别？</em><br><br><em>我又何必煞费思量？</em><br><br><img src="/2019/05/25/定期感情清零/first.jpg"><br><br>我也曾经煞费思量，<br><br>纠结在“我”和“我们”之间。<br><br><br><br>这令人伤脑筋，<br><br>也很耗费心力。<br><br><br><br>但这次我没有。<br><br>我懒得去计较这段关系中，<br><br>哪一个表情是真心的，<br><br>哪一句话又是假的。<br><br><br><br>他有说过打动我的话，<br><br>也有过令我误会的动作。<br><br><br><br>但在结束之后，<br><br>我没有再像以前一样，<br><br>温存着那些话语和动作。<br><br><br><br>我在心里自嘲，<br><br>这算是一种进步吧。<br><br><br><br>还能记得的画面是，<br><br>最后一次一起坐地铁，<br><br>他快到站要下车了。<br><br>我问他，<br><br>“以后还会再见面吗？”<br><br>他笑着说，<br><br>“会的。”<br><br><br><br>车门打开。<br><br>他摸了摸我的头，<br><br>下车，<br><br>又在门口转过身来，<br><br>再次挥手和我说拜拜。<br><br><img src="/2019/05/25/定期感情清零/second.jpg"><br><br>我那时也相信，<br><br>是会再见面的。<br><br>但现在想来，<br><br>他会回头，<br><br>也是觉得我们不会再见面了。<br><br><br><br>这个画面我一直记得，<br><br>是因为在后来的日子里想起来，<br><br>我觉得那就是一个信号，<br><br>一个对方会离开我生活的信号。<br><br><br><br>他从未和我说过，<br><br>他有女朋友，<br><br>所以通过别人口中知道之后，<br><br>我快速地停止了喜欢。<br><br><br><br>我退出得很快，<br><br>甚至带着一种无所谓的坦荡。<br><br><br><br>“反正他既不是我喜欢得最多的一个，<br><br>也不是最好的一个。”<br><br><br><br>删掉所有聊天记录的那天晚上，<br><br>我和同事说，<br><br>想吃水果，吃很多很多水果。<br><br><br><br>于是我们三个人去水果店，<br><br>买了 150 块钱水果。<br><br>然后坐在便利店里，<br><br>大口大口地咀嚼着西瓜和菠萝。<br><br>甜味就像一种万能的溶液，<br><br>把我所有的情绪都溶解掉。<br><br><br><br><strong>很奇怪，</strong><br><br><strong>我过得比以前快乐更多，</strong><br><br><strong>生活里的各种情绪，</strong><br><br><strong>也比以前更加明显和热烈。</strong><br><br><img src="/2019/05/25/定期感情清零/third.jpg"><br><br>某一天我才想通了为什么，<br><br>大概是我的胜负心仍然在作祟。<br><br><br><br>因为在喜欢他的时间里，<br><br>我在他那里失去的筹码太多了。<br><br><br><br>所以不喜欢他之后，<br><br>我一点也不愿意失落和难过，<br><br>这样会失去更多的筹码。<br><br><br><br><strong>我想起以前，</strong><br><br><strong>得不到喜欢的人，</strong><br><br><strong>会故意透露自己的难受，</strong><br><br><strong>企图让对方觉得内疚。</strong><br><br><br><br>我在朋友圈发自己在操场上坐着的图，<br><br>然后说，<br><br>“好想学会喝酒啊，<br><br>这样就可以忘掉所有烦心事了。”<br><br><br><br>我还说，<br><br>“春天会过去的，真心也会。”<br><br><br><br>这些都是发给特定的人看的，<br><br>我想着，<br><br>要是他知道我的难受就好了。<br><br><br><br>但其实，<br><br>一段关系中，<br><br>内疚是无用的。<br><br><br><br>一来是对方可能压根就不在意你，<br><br>二来就算是内疚，也并不能转化为喜欢。<br><br><img src="/2019/05/25/定期感情清零/fourth.jpg"><br><br>很多女孩在爱情中都变得傻傻的，<br><br>傻到可以将很多种感觉都混淆成喜欢。<br><br>说白了也不是混淆，<br><br>只是因为“被骗”。<br><br>被对方骗，<br><br>被自己骗。<br><br><br><br>这都是，<br><br>我经历过一些失败关系后，<br><br>才明白的道理。<br><br><br><br>另一点是，<br><br>这段关系让我对“付出真心”这件事，<br><br>产生了一些后怕。<br><br><br><br>朋友 Kitty 说，<br><br>你永远不知道，<br><br>自己的真心会以哪种方式被浪费掉。<br><br><br><br>这句话戳到我了。<br><br><br><br>这几天皮卡丘大电影上映，<br><br>我老是想起我的可达鸭。<br><br>那是吃麦当劳开心乐园套餐送的玩具，<br><br>我也只有那么一只。<br><br><br><br>但我送给他了。<br><br>我猜，<br><br>他大概早就不知道丢到什么地方去了。<br><br><br><br>这可能是爱情的一点坏处？<br><br>你不能保证，<br><br>对方也同样珍视你付出的真心。<br><br><br><br>我也听过很多爱情道理。<br><br>对于一个几乎没恋爱过的人来说，<br><br>身边朋友的经历总是让我引以为戒。<br><br><br><br>但我慢慢发现，<br><br>故事每天都在发生，<br><br>每天都比昨天更狗血、更无情。<br><br>时间长了，<br><br>我也开始警惕起这些道理和经历。<br><br><br><br><strong>原来对一些人来说，</strong><br><br><strong>情感关系可以只是一个游戏。</strong><br><br><img src="/2019/05/25/定期感情清零/fifth.jpg"><br><br>一个朋友便热衷于这样的游戏。<br><br>喜欢他的女孩他从不拒绝，<br><br>他深谙怎样的举动可以撩到女孩，<br><br>和一个人在一起不是因为喜欢，<br><br>只是因为需要一个前任的替代品。<br><br><br><br>我从心底里鄙夷，<br><br>那些将情感当做游戏的人。<br><br>正因为他们，<br><br>我们遵守的情感规则才不起作用。<br><br>我们认知里的爱情，<br><br>也变得不再纯粹。<br><br><br><br>所以我只能，<br><br>祝那些视情感为游戏的人，<br><br>日后想真心付出时，<br><br>也遇到同等的情感玩家。<br><br><br><br>写下这些的时候，<br><br>我发现，<br><br>自己已经想不起来，<br><br>我们相处过程中的很多细节了。<br><br><br><br>它们的的确确，<br><br>正在清零。<br><br><br><br>必须得承认的是，<br><br>我在这里消耗了一些勇气，<br><br>也很难再找回来。<br><br><br><br>但我想，<br><br>剩下的勇气，<br><br>我还够用。<br><br><img src="/2019/05/25/定期感情清零/sixth.jpg"><br><br></center><!-- rebuild by neat -->]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>恋爱</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础 树状数组 大数计算</title>
    <url>/2019/03/19/Java%E5%9F%BA%E7%A1%80-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E5%A4%A7%E6%95%B0%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><p>在试图解决苹果树下摘苹果的ACM题目，想要学习怎么用Java表示多叉树的时候，突然发现了这个算法，使用二分法来计算大数，且效率很高。在看到它的实现原理瞬间，着实感到惊艳。</p><a id="more"></a><p><img src="/2019/03/19/Java基础-树状数组-大数计算/84367-106.jpg"></p><h2 id="一、树状数组是干什么的？"><a href="#一、树状数组是干什么的？" class="headerlink" title="一、树状数组是干什么的？"></a>一、树状数组是干什么的？</h2><p>​ 平常我们会遇到一些对数组进行维护查询的操作，比较常见的如，修改某点的值、求某个区间的和，而这两种恰恰是树状数组的强项！当然，数据规模不大的时候，对于修改某点的值是非常容易的，复杂度是O(1)，但是对于求一个区间的和就要扫一遍了，复杂度是O(N)，如果实时的对数组进行M次修改或求和，最坏的情况下复杂度是O(M<em>N)，当规模增大后这是划不来的！而树状数组干同样的事复杂度却是O(M</em>lgN)，别小看这个lg，很大的数一lg就很小了，这个学过数学的都知道吧，不需要我说了。</p><p>​ 申明一下，看下面的文章一定不要急，只需要看懂每一步最后自然就懂了。</p><h2 id="二、树状数组怎么干的？"><a href="#二、树状数组怎么干的？" class="headerlink" title="二、树状数组怎么干的？"></a>二、树状数组怎么干的？</h2><p>​ 先看两幅图，下面的说明都是基于这两幅图的，左边的叫A图吧，右边的叫B图：</p><p><img src="/2019/03/19/Java基础-树状数组-大数计算/A.jpg"> <img src="/2019/03/19/Java基础-树状数组-大数计算/B.jpg"></p><p><img src="/2019/03/19/Java基础-树状数组-大数计算/shot.png"></p><p>是不是很像一颗树？对，这就是为什么叫树状数组了～先看A图，a数组就是我们要维护和查询的数组，但是其实我们整个过程中根本用不到a数组，你可以把它当作一个摆设！</p><p>c数组才是我们全程关心和操纵的重心。先由图来看看c数组的规则，其中c8 = c4+c6+c7+a8，c6 = c5+a6……先不必纠结怎么做到的，我们只要知道c数组的大致规则即可，很容易知道c8表示a1～a8的和，但是c6却是表示a5～a6的和，为什么会产生这样的区别的呢？或者说发明她的人为什么这样区别对待呢？</p><p>答案是，这样会使操作更简单！看到这相信有些人就有些感觉了，为什么复杂度被lg了呢？</p><p>可以看到，c8可以看作a1～a8的左半边和+右半边和，而其中左半边和是确定的c4，右半边其实也是同样的规则把a5～a8一分为二……继续下去都是一分为二直到不能分，可以看看B图。</p><p>怎么样 ？是不是有点二分的味道了？对，说白了树状数组就是巧妙的利用了二分，她并不神秘，关键是她的巧妙！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>我从3次考研失败中明白了什么&lt;Cover By 木兰&gt;</title>
    <url>/2019/03/16/%E6%88%91%E4%BB%8E3%E6%AC%A1%E8%80%83%E7%A0%94%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%98%8E%E7%99%BD%E4%BA%86%E4%BB%80%E4%B9%88-Cover%20By%20%E6%9C%A8%E5%85%B0/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><p>到今年6月，我已经大学毕业整整5年，在这5年时间我考了3次研究生，结果都失败了。考研是我这段时光最重要的一个注脚，我把它记下来，防止自己遗忘。同时也说明一下，这篇问章不是考研成功攻略，更不会回答“我该不该考研“这个问题，只是希望我用5年时间明白的一些 事情有缘人能够看到，从而对自己的生活有所启迪。</p><a id="more"></a><p><img src="/2019/03/16/我从3次考研失败中明白了什么-Cover By 木兰/4256-106.jpg"></p><p><a href="https://www.douban.com/note/380061531/" target="_blank" rel="noopener">https://www.douban.com/note/380061531/</a></p><h2 id="一：荒废大学-首次考研"><a href="#一：荒废大学-首次考研" class="headerlink" title="一：荒废大学 首次考研"></a>一：荒废大学 首次考研</h2><p>我是美术生，经过高中的突击专业训练还有一年的复读，以及还算不错的文化课成绩从郑州考入了广州一所中等偏上大学的美术学院。我的大学生活用“荒废”这个词概括有点后知后觉，当时的我的感受跟现在大不相同，一股子不知道自己想要什么又什么都想要的别扭劲儿，把自己拧巴得烦恼焦躁又抑郁，天天想点不着调的，又受到学校接连几场跳楼事故的影响，心理都有点异常，不得已去求助学校心理咨询，去了两次问题似乎解决了后来就又不去了，总之各种前后矛盾渴望改变又不敢行动的虚无状态。</p><p>就这样到大四上学期，才突然意识到大学生活就要完结顿时慌了神，怎么才能继续留在大学这个象牙之塔呢？似乎只有考研，于是就去考了一场裸考差不多的考试，结果，可想而知。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这个阶段，其实问题出在两个方面，第一是初高中应试教育只注重成绩，自己完全没有培养出自制力和独立学习能力。第二就是国内大学教育的尤其是通常采用放羊式管理同时又太偏重学术性，根本与社会就业脱节，其中美术教育尤甚。我学的平面设计专业（现在都叫视觉传达）其实很好玩很实用，可以学习很多东西的学科，但学校又完全没有成熟的课程体系。</p><p>这两方面相互作用，形成了我虚无主义的倾向，想得多做得少，执行力奇差，这种倾向其实从一开始的小学阶段就有，但到了大学才来了总爆发。最后应该感谢母校的心理救助体系，让我没能步几位自杀者的后尘吧!</p><h2 id="二：工作迷茫-二次考研"><a href="#二：工作迷茫-二次考研" class="headerlink" title="二：工作迷茫 二次考研"></a>二：工作迷茫 二次考研</h2><p>这部分应该重点细说，估计也是很多想辞职考研同学最关心的部分。</p><p>毕业后我经过大半年的曲折终于找到了一份稳定的工作。那个工作的地点在所谓开发区，道路齐整厂房俨然，绿树成荫鲜花常开，此外还有小山迤逦，单说风景简直是世外桃源。可惜枯燥也是真的，我早班车去晚上班车回，年轻的生命在大而无当的办公室里显得空空荡荡，我想这种感觉类似公务员们吧，但却远没有一般公务员轻松和稳定，首先我的工作虽然简单，却相当繁琐，工作量也不算小，一不小心就会出错，而出错就意味着投诉、扣工资、乃至开除。其次这个工作技术含量相当低，一个刚毕业的大专生培训两天就能上手随时可以被取代，这让我内心的恐慌感日益蔓延。因为我早已不是那个天真而纠结大学生，出社会的一年的经历，让我确信了一条，生存是第一位的，而理想也要很重要。我对我的以往做了简单的回顾也开始想办法去改变现状，怎么改变呢，我自然而然地想到了考研，假如我能考回母校，我一定倍加珍惜每个小时，把想学的想做的都做完，当时就是这种简单的想法（估计也是很多同学的心声）。</p><p>作为一个典型的文艺青年，我的执行力一直都是渣。有了考研的计划，但我最多的时间还在纠结，期间我还回到家乡一边找了一份工作慢悠悠做着，一边跟父母兜售我的考研计划，我也像现在亲们一样，求支持，求祝福，求帮助，求鼓励，各种求。但是，父母并不支持，因为他们看来我当时的工作不能算很好，也没很坏，人也老大不小了，安安稳稳地生活最重要，考研太不着调。我期间感情也有变故，总之是受了点刺激，让我意识到只能自己靠自己了，所以我开始攒钱并且暗自制定制定了一个离家出走考研计划。</p><p>2012年下半年，激动人心的时刻终于到来，我提着装有几件换洗衣服的小包，拿着几个月工资攒下来的一笔钱，坐上了南下的火车。我已经事先跟在广州的同学“密谋”好，安排好了住地和生活事宜，出发前我甚至还请了某占星师算了一算能不能考上，她总体意思是可以的，现在回想只能呵呵后了，如果我是占星师，我也不会太打击客人不是。<br>我到了广州的时候已经是8月底，过了中秋才正式复习。我那时候怕英语怕的要死，每天大部分精力都投入到专业中去，晚上回到同学家里，才敢看英语。后来我看英语的时间拖延的越来越晚，不得已我只好过上了昼夜颠倒的生活，晚上看书到凌晨，困了就睡到中午，再起身去学校图书馆复习，晚上再看英语如此循环。时间过得很快，很快就到了考试的日子，拜混乱的生物钟和紧张情绪所赐，我在英语考试前晚华丽失眠。浑浑噩噩出了考场，像死过一回的感觉。专业相对轻松吧，反正填满了卷子。</p><p>最后我的成绩出来了，总分340还不算太难看（艺术类总分最低线320），但英语只有32，差当年最低分数线2分。专业还行，我不死心打电话给导师，导师说别说你没上线，就是上了线，比你高二三十分的都不知道录不录呢！但是当时我是把这句话选择性地遗忘了。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>这次考研其实我犯了两大错误，第一拖了太久，如果我当时能把那份稳定工作的业余时间都用来看英语，搬到公司宿舍节省一些费用也攒点钱，其实完全可以不用从广州折腾到家里又从家里跑回广州也不用寻求任何人的支持。第二就是完全低估了美术史论考研的难度，预留了太少的复习时间。而且考前我找过导师，导师首先告诉了我很多现实的问题，但我只是一头热的选择性忽略，换言之，执行力差什么的不是最致命的，不相信现实只愿意相信自己相信的才是最致命的。</p><h2 id="三：前途混沌-三次考研"><a href="#三：前途混沌-三次考研" class="headerlink" title="三：前途混沌 三次考研"></a>三：前途混沌 三次考研</h2><p>灰头土脸回到家里，父母并没有对不告而别的我大发雷霆，但是我自己情绪低落的不可自拔。因为当时成绩还没出来，也没打算找工作，所以暂时就在家里的小作坊打杂，反正什么都学什么都做吧，做饭刷碗画图接待客人。可以想象从美丽的南国校园，到尘土飞扬的北方城乡结合部小作坊区可以想象我的心理落差~一次系着那种丑到爆的罩衣刚做完大锅饭，一个客户正好回市区，于是就坐在他面包车后箱的麻袋上趁车回家，客户边开车还边跟我聊天，他说看你这么年轻怎么跑去给人家做饭。听完之后心里不知道是什么滋味，总之是百味陈杂。我没有嫌弃做饭工作，好歹也是自食其力，哪怕是个作坊做饭的也没什么，但我想起了自己种种美好的过往时光，以及曾经五彩斑斓的梦想，还有两分而不过线的巨大遗憾，考研，又像一条滑溜溜的蛇钻入脑门。</p><p>我又一次向父母提出考研，经过了上次的离家出走，他们对我考研执念体会深刻，这次他们也没多说什么。我回到家里市区的套房，专心准备考研。这回我从现实考虑，已经不打算考回母校了毕竟山长水远的，综合考虑本地的一所重点大学才是最佳选择。于是我买齐资料，开始复习。那段日子颇像闭关修行，我吸取第二次的教训，按时作息，劳逸结合，还要感谢我在毕业之后学会的新技能——做饭，我的三餐荤素搭配，颇有营养，还能顺道给父母准备早晚餐。但我的内心还是有种种焦虑不安，被我用表面的意志勉力压制，最后还是来了个大爆发。考前两星期我连续3天失眠，后来我想来想去睡不好是个大问题，平生第一次去医院精神科开安眠药，那个女医师听到我的失眠原因之后哑然失笑，说你们年轻人就是这么脆弱，可能这件事在她眼里根本不算事儿吧！总之吃了安眠药之后我睡眠就还算正常了。</p><p>考试考的很快，没有失眠没有意外。唯一比较吃惊的是，考研人数异常的多，还有绝大部分都是女生。这次我英语考了38，过了线可依然没考上，母校导师的话就被我重新从记忆里翻出，当时我是选择性地遗忘了的。</p><p>总结：其实这次考研更多的对上次不过线的不甘心吧！还有我其实对当时自己窝在家里的现状及其不满意，却没有更多的改变勇气。这次从策略上来说，还是客场作战，对专业题型、题量都没有一个准确的估计，更是低估了大家考研的热度。不过无所谓了，在那场闭关之中我也想明白了一些道理，自己放过了自己。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我的三次考研，其实都是在打一场开始就能猜到结果的必败战争。有时候我也想，如果我考研之前就明白这些道理就好了~但是跟那个八个烧饼的故事是一样的，是不可能的。我也问我自己有没有后悔，真的没有。因为对当时的我来说，考研是最重要的可以抛下其它一切。世人都很重视结果，就好像烧开水，没烧到100°C就算失败，可是我自己知道，我可能烧的时间有点短，可能第一次是50°C第二次是70°C一直在进步，他们看不到可是我自己知道。现在我知道了我把考研当成了一个魔法石，我对过往的遗憾，对现实的失望，对未来的期许，学习的欲望，改变的渴望等等等等，似乎用一个考研成功都能点石成金重头再来。</p><p>我常常想如果说六零后的青春背景是那一场史无前例的浩劫，还有上山下乡谱写的青春挽歌，七零后的青春是文艺的黄金时代还有那个广场前的不可言说。那么，我们八零后的青春背景就是大学扩招以及考研热考公务员热 留在北上广和逃离北上广的纠结~时代的洪流滚滚而来，我们被夹裹其中来不及思考就要匆匆向前。我用的的青春经历了考研，它给我的影响将持续一生。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果树下摘苹果——ACM选拔题目训练（Easy难度）</title>
    <url>/2019/03/16/%E8%8B%B9%E6%9E%9C%E6%A0%91%E4%B8%8B%E6%91%98%E8%8B%B9%E6%9E%9C%E2%80%94%E2%80%94ACM%E9%80%89%E6%8B%94%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83%EF%BC%88Easy%E9%9A%BE%E5%BA%A6%EF%BC%89/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree.</p><p>The tree has <em>N</em> forks which are connected by branches. Kaka numbers the forks by 1 to <em>N</em> and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree.</p><p>The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka?</p><a id="more"></a><h2 id="中文描述"><a href="#中文描述" class="headerlink" title="中文描述"></a>中文描述</h2><p>卡卡家外面有一棵苹果树。每年秋天，树上都会长出许多苹果。卡卡非常喜欢苹果，所以他一直在精心培育大苹果树。</p><p>这棵树有N个叉子，它们通过树枝相连。卡卡用1到n给叉编号，而根总是用1编号。苹果会在叉子上生长，两个苹果不会在同一个叉子上生长。为了研究苹果树的生产能力，卡卡想知道一个子树里有多少苹果。</p><p>问题是，一个新苹果可能会在一个空叉子上生长一段时间，卡卡可能会从树上摘一个苹果作为甜点。你能帮卡卡吗？</p><p><img src="/2019/03/16/苹果树下摘苹果——ACM选拔题目训练（Easy难度）/appleTree.gif"></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line contains an integer <em>N</em> (<em>N</em> ≤ 100,000) , which is the number of the forks in the tree.<br>The following <em>N</em> - 1 lines each contain two integers <em>u</em> and <em>v</em>, which means fork <em>u</em> and fork <em>v</em> are connected by a branch.<br>The next line contains an integer <em>M</em> (<em>M</em> ≤ 100,000).<br>The following <em>M</em> lines each contain a message which is either<br>“<strong>C x</strong>“ which means the existence of the apple on fork <em>x</em> has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.<br>or<br>“<strong>Q x</strong>“ which means an inquiry for the number of apples in the sub-tree above the fork <em>x</em>, including the apple (if exists) on the fork x<br>Note the tree is full of apples at the beginning</p><p>第一行包含一个整数n（n≤100000），它是树中的叉数。下面的n-1行分别包含两个整数u和v，这意味着fork u和fork v通过分支连接。</p><p>下一行包含整数m（m≤100000）。</p><p>以下M行中的每一行都包含一条消息，“C x”表示叉x上苹果的存在已经改变。也就是说，如果叉子上有一个苹果，那么卡卡就会摘下来；否则，一个新的苹果就会长在空叉子上。或“Q x”表示对叉X上方子树中苹果数量的查询，包括叉X上的苹果（如果存在）。</p><p>注意：这棵树一开始就满是苹果</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For every inquiry, output the correspond answer per line.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">3</span><br><span class="line">Q 1</span><br><span class="line">C 2</span><br><span class="line">Q 1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="自序"><a href="#自序" class="headerlink" title="自序"></a>自序</h2><p>这里一开始我就意识到要用到树的数据结构来遍历和增加节点，但是我开始以为是二叉树，随后在老师的提醒下发现并不是二叉树，而是随意树。这就有点尴尬，二叉树我都忘得差不多了，你还要给我个树，我TM怎么记得是怎么表示的啊？</p><p>我甚至开始还以为要用二维数组来表示树，最后发现是我太天真。当然能够将树忘得这么干净，我也确实是太自傲了。</p><p>我总以为我记得那些图、树、链表等等东西，总感觉随便一个人来面试我我都没问题，结果一道小题目就让我跪了。数据结构的基础，我真的没我想象中的那么好，甚至是曾经难以相信的差。</p><p>在考场上我不断不断地问我自己，树怎么表示？用数组怎么表示？树的节点怎么定义？树的遍历怎么搞？最简单的前序遍历的递归方式怎么写？怎么添加节点和修改节点？</p><p>最后我不得不承认，我确实忘得一干二净，在考场上开始垂头丧气，挣扎了那么久，最后12点整了，还是没做出来。</p><p>如今趁着余温未散，搜到了这个题目的原题，再复习一遍数据结构的树。</p><h2 id="快速复习树的百科废话"><a href="#快速复习树的百科废话" class="headerlink" title="快速复习树的百科废话"></a>快速复习树的百科废话</h2><p><img src="/2019/03/16/苹果树下摘苹果——ACM选拔题目训练（Easy难度）/tree.jpg"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树状图是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li><p>每个结点有零个或多个子结点；</p></li><li><p>没有父结点的结点称为根结点；</p></li><li><p>每一个非根结点有且只有一个父结点；</p></li><li><p>除了根结点外，每个子结点可以分为多个不相交的子树；</p></li></ul><p>树（tree）是包含n（n&gt;=0）个结点的有穷集，其中：</p><ul><li><p>每个元素称为结点（node）；</p></li><li><p>有一个特定的结点被称为根结点或树根（root）。</p></li><li><p>除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，……Tm-1，其中每一个集合Ti（1&lt;=i&lt;=m）本身也是一棵树，被称作原树的子树（subtree）。</p></li></ul><p>我们可以形式地给出树的递归定义如下:</p><ul><li>单个结点是一棵树，树根就是该结点本身。</li><li>设T1,T2,..,Tk是树，它们的根结点分别为n1,n2,..,nk。用一个新结点n作为n1,n2,..,nk的父亲，则得到一棵新树，结点n就是新树的根。我们称n1,n2,..,nk为一组兄弟结点，它们都是结点n的子结点。我们还称T1,T2,..,Tk为结点n的子树。</li></ul><p>空集合也是树，称为空树。空树中没有结点。</p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>节点的度：一个节点含有的子树的个数称为该节点的度；</li><li>叶节点或终端节点：度为0的节点称为叶节点；</li><li>非终端节点或分支节点：度不为0的节点；</li><li>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li><li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li><li>树的度：一棵树中，最大的节点的度称为树的度；</li><li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>树的高度或深度：树中节点的最大层次；</li><li>堂兄弟节点：双亲在同一层的节点互为堂兄弟；</li><li>节点的祖先：从根到该节点所经分支上的所有节点；</li><li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li><li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li></ul><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ul><li>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;</li><li>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；</li><li>二叉树：每个节点最多含有两个子树的树称为二叉树；</li><li>完全二叉树</li><li>满二叉树</li><li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li></ul><h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><p>定义一棵树的根结点层次为1，其他节点的层次是其父结点层次加1。</p><p>一棵树中所有结点的层次的最大值称为这棵树的深度。</p><h3 id="符号表达法"><a href="#符号表达法" class="headerlink" title="符号表达法"></a>符号表达法</h3><p>用括号先将根结点放入一对圆括号中，然后把它的子树由左至右的顺序放入括号中，而对子树也采用同样的方法处理；同层子树与它的根结点用圆括号括起来，同层子树之间用逗号隔开，最后用闭括号括起来。如前文树形表示法可以表示为：（1（2（5（9，10）），3（6，7），4（8）））</p><h3 id="遍历表达法"><a href="#遍历表达法" class="headerlink" title="遍历表达法"></a>遍历表达法</h3><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=9c2a14928e1001e94a3c130d880f7b06/9d82d158ccbf6c81bfec7193bf3eb13532fa40f5.jpg" alt="img"></p><p>遍历表达法有3种方法：</p><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><p>例如右图：</p><ul><li>其先序遍历为ABDECF</li><li>其中序遍历为DBEAFC</li><li>其后序遍历为DEBFCA</li></ul><h2 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h2><p>我在经过一个下午的煎熬，从下午一点多到如今，中间吃个饭睡个觉，然后便被这道题纠缠住。</p><p>我其实不得不承认了，我过往没学过多叉树的实现，不知道用链表实现多叉树的原理所在。而只是一厢情愿的认为二叉树和树差不了多少，其实也确实差不了多少，但问题在于我总静不下心去看那些实现源码，不愿意去思考Node节点代码中为什么要设置一个ParentId和SelfId，不知道LinkList应该写在Node节点代码中，还是写在NodeTree的代码中，我不知道在用链表实现树的过程中，应该分3层——一层Node、一层NodeTree、最上面一层NodeTreeLink，还是分2层——直接一层Node、最上面一层NodeTreeLink</p><p>无数问题在困扰着我，而我还天真的以为数据结构学的多好，以为多叉树和二叉树差不多，以为Java实现会更容易，以为我能手动实现一遍树，以为我自己能直接推导。。</p><p>被打脸的好狠</p><h2 id="只能留下这个坑，日后再来弄吧（2019-3-17）"><a href="#只能留下这个坑，日后再来弄吧（2019-3-17）" class="headerlink" title="只能留下这个坑，日后再来弄吧（2019.3.17）"></a>只能留下这个坑，日后再来弄吧（2019.3.17）</h2><h2 id="好了，我回来了（2019-3-19）"><a href="#好了，我回来了（2019-3-19）" class="headerlink" title="好了，我回来了（2019.3.19）"></a>好了，我回来了（2019.3.19）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTest2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> branchNum = input.nextInt();</span><br><span class="line"></span><br><span class="line">		AppleNodeTree tree = <span class="keyword">new</span> AppleNodeTree();</span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">		tree.insert(root, root, <span class="number">0</span>);<span class="comment">//这里我遇到了一个问题，那就是我要怎么将第一个节点插入到tree里面呢？此时tree是空的，我也找不到父节点，怎么插入？</span></span><br><span class="line">		<span class="comment">//答案就是第一个节点本身就是树，所以本质上插入第一个节点，就是自己插入自己。但是有一个问题，因为第一个节点本身已经是树了，所以后面使用insert方法的时候，tree会默认缺失首节点的个数</span></span><br><span class="line">		<span class="comment">//即如果一共有5个节点，那么display方法只能显示4个节点，原因一言难尽，主要还是归因于我对树的结构的不理解吧</span></span><br><span class="line">		<span class="comment">//我的解决方法，就是在display方法中做一个判断，让第一个节点也能够显示</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; branchNum - <span class="number">1</span>; x++) &#123;<span class="comment">// 为什么要减一？因为如果要求输入5根树枝，那么你只能输入4根，原因是，第一根已经确定为1了。无法修改</span></span><br><span class="line">			<span class="keyword">int</span> parentId = input.nextInt();</span><br><span class="line">			<span class="keyword">int</span> myselfId = input.nextInt();</span><br><span class="line">			TreeNode insertNode = <span class="keyword">new</span> TreeNode(myselfId, parentId);</span><br><span class="line">			tree.insert(root, insertNode, parentId);</span><br><span class="line">		&#125;</span><br><span class="line">		tree.display(root, <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 正式开始</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">int</span> operationTime = input.nextInt();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; operationTime; x++) &#123;</span><br><span class="line">			String operation = input.next();</span><br><span class="line">			<span class="keyword">char</span> operationType = operation.charAt(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">int</span> operationLocation = input.nextInt();</span><br><span class="line">			<span class="keyword">if</span> (operationType == <span class="string">'Q'</span>) &#123;</span><br><span class="line">				tree.countApple(operationLocation, root, <span class="keyword">false</span>);</span><br><span class="line">				System.out.println(tree.countAppleNumber);</span><br><span class="line">				tree.countAppleNumber = <span class="number">0</span>;<span class="comment">//在每次查询之后，必须重新设置为0，不然这个值会累积，导致最终结果出错</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				tree.editApple(operationLocation, root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> myselfId;<span class="comment">//自身的标识ID，对于别人来说，这个自身id将成为别人的父id标识</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> parentId;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> hasApple;</span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;TreeNode&gt; list;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		myselfId = <span class="number">1</span>;</span><br><span class="line">		parentId = <span class="number">0</span>;</span><br><span class="line">		hasApple = <span class="keyword">true</span>;</span><br><span class="line">		list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> myselfId, <span class="keyword">int</span> parentId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myselfId = myselfId;</span><br><span class="line">		<span class="keyword">this</span>.parentId = parentId;</span><br><span class="line">		hasApple = <span class="keyword">true</span>;</span><br><span class="line">		list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hasApple;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasApple</span><span class="params">(<span class="keyword">boolean</span> hasApple)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.hasApple = hasApple;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMyselfId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> myselfId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyselfId</span><span class="params">(<span class="keyword">int</span> myselfId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myselfId = myselfId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> parentId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParentId</span><span class="params">(<span class="keyword">int</span> parentId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.parentId = parentId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LinkedList&lt;TreeNode&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(LinkedList&lt;TreeNode&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.list = list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleNodeTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> countAppleNumber = <span class="number">0</span>;<span class="comment">//这个共享变量是为了计算苹果数，但是需要记住，每次查询之后一定要重新归零，不然会累积的</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AppleNodeTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(TreeNode currentRoot, <span class="keyword">int</span> deepth)</span> </span>&#123;<span class="comment">//这里的本质，其实就是不断的重新定义当前根节点，从而进行遍历.如此说来，这个深度除了显示那几个横杠--,也没有其他用处了</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (currentRoot.getMyselfId() == <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.print(currentRoot.getMyselfId() + <span class="string">"  "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; childList = currentRoot.getList();</span><br><span class="line">		<span class="keyword">if</span> (childList == <span class="keyword">null</span> || childList.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; childList.size(); x++) &#123;</span><br><span class="line">			System.out.print(getLevelStar(deepth) + childList.get(x).getMyselfId() + <span class="string">"  "</span>);</span><br><span class="line">			display(childList.get(x), deepth + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(TreeNode currentRoot, TreeNode insertNewNode, <span class="keyword">int</span> insertNodeParentId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (insertNodeParentId == currentRoot.getMyselfId()) &#123;</span><br><span class="line">			currentRoot.getList().add(insertNewNode);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; childList = currentRoot.getList();</span><br><span class="line">		<span class="keyword">if</span> (childList.isEmpty() || childList == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; childList.size(); x++) &#123;</span><br><span class="line">			insert(childList.get(x), insertNewNode, insertNodeParentId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countApple</span><span class="params">(<span class="keyword">int</span> currentOperationLocation, TreeNode currentRootFindValue, <span class="keyword">boolean</span> couldNotFindNodeFlag)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这里为什么要有一个couldNotFindNodeFlag的标识变量？原因很简单，这里计算苹果要分两步：</span></span><br><span class="line">		<span class="comment">//1.先找到那个目标子节点，而且不同于普通的递归遍历，这里如果已经找到子节点了，就不应该再去递归遍历其他的子节点了，而应该只递归遍历这个子节点的下属链表</span></span><br><span class="line">		<span class="comment">//2.所以我们需要一个标识变量，当未找到那个目标子节点的时候，我们可以去随便遍历整个多叉树，但是一旦找到了那个目标子节点了，就修改标识变量，从而让程序只执行一部分代码了</span></span><br><span class="line">		<span class="keyword">if</span> (currentOperationLocation == currentRootFindValue.getMyselfId() || couldNotFindNodeFlag) &#123;</span><br><span class="line">			couldNotFindNodeFlag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (currentRootFindValue.isHasApple()) &#123;</span><br><span class="line">				countAppleNumber++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; currentRootFindValue.getList().size(); x++) &#123;</span><br><span class="line">				countApple(currentOperationLocation, currentRootFindValue.getList().get(x), couldNotFindNodeFlag);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			LinkedList&lt;TreeNode&gt; childList = currentRootFindValue.getList();</span><br><span class="line">			<span class="keyword">if</span> (childList == <span class="keyword">null</span> || childList.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; childList.size(); x++) &#123;</span><br><span class="line">				countApple(currentOperationLocation, childList.get(x), couldNotFindNodeFlag);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editApple</span><span class="params">(<span class="keyword">int</span> currentOperationLocation, TreeNode currentRootFindValue)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这里也同理，未找到目标子节点之前，随便遍历，但是一旦找到了，只需一步，然后直接结束。</span></span><br><span class="line">		<span class="keyword">if</span>(currentRootFindValue.getMyselfId() == currentOperationLocation)&#123;</span><br><span class="line">			<span class="keyword">if</span>(currentRootFindValue.isHasApple())&#123;</span><br><span class="line">				currentRootFindValue.setHasApple(<span class="keyword">false</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				currentRootFindValue.setHasApple(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		LinkedList&lt;TreeNode&gt; childList = currentRootFindValue.getList();</span><br><span class="line">		<span class="keyword">if</span>(childList == <span class="keyword">null</span> || childList.isEmpty())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; childList.size(); x++)&#123;</span><br><span class="line">			editApple(currentOperationLocation, childList.get(x));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLevelStar</span><span class="params">(<span class="keyword">int</span> deepth)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//打印level次级符号而已</span></span><br><span class="line">		deepth += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">char</span>[] level = <span class="keyword">new</span> <span class="keyword">char</span>[deepth];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; level.length; x++) &#123;</span><br><span class="line">			level[x] = <span class="string">'-'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于java实现多叉树的操作，非常感谢<a href="https://blog.csdn.net/sss1342746626/article/details/78868026" target="_blank" rel="noopener">https://blog.csdn.net/sss1342746626/article/details/78868026</a>这个博客，让我豁然开朗，写的通俗易懂</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年Java工作经验点滴</title>
    <url>/2019/03/15/2018%E5%B9%B4Java%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E7%82%B9%E6%BB%B4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 05 2020 13:33:18 GMT+0800 (GMT+08:00) --><p>​ 2018那年，我在广州实习工作近一年的工作项目小结，当然只是一部分的</p><p>​ 1.如果遇到，只需向后台传送单个元素，而不是整个表单的情况的话，可以直接用jquery获取该输入框的值，然后在ajax中，使用<br>​ <code>$.post(path + &quot;/admin/bookManager/findTypeNameToValue&quot;,{typeName: typeName}, function (backData) {callback(backData);});</code><br>​ 注意，需要自行设置传送名称和传送值，此时input中的name已经失效</p><a id="more"></a><p><img src="/2019/03/15/2018年Java工作经验点滴/铳梦0.jpg"></p><p>2.遇到需要两次转换的情况的时候，如需要将该中文转为对应的数字，然后再将该数字进行搜索的话，则要使用嵌套：<br><code>&lt;u&gt;DataHandler.findTypeNameToValue(typeNameBooks, function (backDatas) {DataHandler.findTypeNameBooks(backDatas, function (backData) {console.log(backData);});});</code></p><p>3.在dao层中，如果拼写sql语句的话，就必须执行Page<map>page =this.findPageBySql方法,然而，这其中必须存在一个pageble和class文件，因此可以实现写一个无需前端js注入数值的form类，让该类集成pageble，然后使用setter方法注入，这样一石二鸟。</map></p><p>4.在使用SpringMVC中，如果想要在controller通过return进行页面跳转，那么记得，请务必去除@ResponseBody标记，否则的话，对于SpringMVC而言，那个return “/admin/helpUp/bookManager/index” 只是返回一个字符串，而不是返回一个跳转链接</p><p>5.在使用SrpingMVC跳转时，当使用return语句时，不要忘记加“/”这个斜杠。如你写的是return “admin/suggestion/index”没反应，应该写成return “/admin/suggestion/index”才行啊</p><p>6.当运行server后发现提示“无法创建bean”或者“无法解析该bean”时，请第一先查看service层的@Service注解是否有加？其次观察DAO层的注解是否有加？检查构造方法，尽可能的别用构造方法的初始化，我就报错了好多次</p><p>7.如果遇到某些难以言表的错误，明明不可能出现，但还是出现了，就clean install，不但是全局的，全局可能不起作用，而应该深入每一个小模块，逐个的clean install</p><p>8.如何制造当修改或新增成功后返回主页面的效果呢？这个是无法在controller中实现，而应该在先把成功信息传给前台js，然后js判断是成功信息，就重新发送一次请求给controller,让页面回到主页面。</p><p>9.想批量删除元素吗？首先要解决多选后，怎么向controller传递id集合的问题？那就是先var array[]；然后再for循环遍历并且赋值——array.push(data[i].id),最后通过$post（“url”，{‘arr’:arr.join(‘,’))}）,最后再controller中写明传参（Long[] ids）即可</p><p>10.当点击按钮时，会弹出一个可输入的框————如登录注册回复详情等等功能————这个框除非提交否则不会自动消失，怎么实现这个框呢？<br><code></code>msgBox.exWindow.open({<code></code>title: ‘回复’,<code></code>url: path + ‘/admin/message/online/toPage/reply?id=’ + data.id,<code></code>width: ‘600px’,<code></code>height: ‘370px’,<code></code>close: function (result) {<code></code>if (result) {<code></code>$form.submit();<code></code>}<code></code>}<code>});</code></p><p>11.想通过form表单类让前台ajax传给后台的数据项，一一自动写入form表单类中的每一个属性中，然而却发现有问题，那就是通过form表单类做中介来传输数据时，前台可以传给后台，然而后台处理完毕后想要跳转到另一页面（使用return “admin/bookManager/findTypeNameToValue”之类的跳转方式）时，却发现跳转失败，并且反而变成后台传给前台这个页面的HTML代码了（如果你在ajax中将返回值打印出来便可知），苦寻思路，终究难解，所以只能放弃form表单类，而改用？占位符的方式逐个传输数据给后台，在形参中一一接受。<br>————————————换种思路：那就是不要直接return路径进行跳转，把返回类型改为Message，当登录成功后，设置SUCCESS_MSG的content为登陆成功，然后将该message返回前台js，当ajax接收到后，进行判断，判断message的type是success还是error，如果是success的话，那么重新发送一次请求，向controller请求跳转到主页，便可以啦。</p><p>12.如果想要使用username和password进行登录操作，虽然简单，但是不安全，password一般长度为20位，如果只是单纯的从数据库中抽出直接进行比对的话，就容易遇到某些隐藏的错误异常和危险。所以应该进行加密，并且使用散列算法加密，因为散列算法的不可逆过程，致使一旦加密城长字符串的话，便无法再度转换回普通字符串。那么如何进行校验呢？答案就是，应该使用相同的散列加密算法，再次对用户输入的password进行加密运算，然后从数据库中调取原加密字符串，二者进行比对即可。</p><p>13.当我想要通过对后台返回的page数据进行分页操作时，发现一旦在js中写上这句话”var options = self.pageBar.pageBar(‘options’);”，程序直接不执行了，后面的完全停止运行，我不知道哪里出了错？</p><p>14.vue.js是一个MVVM框架，它的宗旨是”数据驱动，组件系统”。不同于jquery通过鼠标键盘以及其他写定的方式来操作dom元素，从而达到页面的变化，vue.js正是不同于这一点，它是数据驱动的，也就是无需通过鼠标键盘来操作来dom元素，而是通过model层（数据存放处）判断数据是否发生了变化，一旦有变化，立刻通过ViewModel这个黑盒子，更改view层的效果实现，反过来，如果view层监听到了某些点击/时间等等事件的发生时，也会通过ViewModel层这个黑盒子，去进一步修改model的元素。</p><p>15.由此可知，在vue.js有一个数据绑定叫”v-model”,这个标签表示随时监听这个div中的值（比如在input中放置这个标签），一旦发现这个值改变，于是直接修改model层的数值，从而让有使用到这个model元素的所有dom元素全体改变数值。</p><p>16.vue.js的思路结构是：MVVM框架，于是我们发现，一个完整的vue.js程序，就必须要有三个组件，即model、view和viewModel这三个。一般而言，view写在html页面的正体即body中（也可添加一些v-if/v-for等等标签，但是这些标签依旧属于view层）,而model一般是存储数据的地方，这个model可以单独写，那么就应该写成var elemet = { message ： “hello world”}这种弱类型对象形式。不过还有另一种写法，那就是将model放在viewModel层中。不同于model是一个弱类型对象（更直接点，应该是类似于c语言中的结构体，只存在字段和对应数值，也可等同于数据表的另一种写法而已），viewModel是一个真正的对象，因为他的意义，是为了连接model层和view层，它要将拿到的model层的数值，传送给view层，所以它也是一个对象，但是功能决然不同。model对象只是存储数据，然而viewModel更类似于java后台中的Service层，它要处理数据和加工，都在这里。因此viewModel的创建方式，变成 new Vue（{el:<strong>，data：</strong>}）,第一个el是绑定view，第二个data是绑定model，那么就很清楚了，model与viewModel同为对象，那么就不用绑定model，可以直接将model写在data中了。</p><p>17.vue.js中，index.js负责路由跳转。index.js的功能，就是先创建路由管理员router，然后在路由管理员router里面创建一个routes数组集合，最后再在routes集合中一个一个的写清楚route的单独个体路由。最后使用vue.use(Router);</p><p>vue中，没有了model的概念，在jsp中，前端与后台有一个调度控制器和ModelAndView作为中间者，后台接受前台请求，处理结构后，直接return 到jsp页面，modelandview便自动带到了目标jsp中。然而vue不同，它的思路是：先路由跳转，跳转后再由新页面发起请求给后台，后台处理后返回一个Map或者Page给该vue，该vue的js中存在一个form名称的“实体类”，map和page都会在这里被解析成一个一个的属性名并自动复制给这个实体类，然后渲染画面。</p><p>18.在vue的路由中，在同一个routes中，允许存在两个路径不同，但指向结果相同的route，问题是如果两个route一模一样的话会报错的，因此必须将其他的相同的route的component标签去掉，改用重定向标签，即redirect标签，并且内容也要改变。知道什么叫重定向么？那就是再一次发送一次路由请求，请求到那个唯一的、存在component标签的route中。所以，redirect的内容要改变为与那个唯一的route的path相同的存在即可，否则会报错。</p><p>19.我去，我在springboot里面的实体的Repository中困了半天,总是自动报错然后停止了服务器。有三个问题：1.别写sql语句，请写hql语句，因为sql语句中的*号会报错。2.使用@Query注解时，请一定要在形参传递中加入Pageable。3，请不要让Repository集成JpaRepository，如果继承他的话，应该还要写setBaseRepository这个方法，不然又报错。 pageable这个参数，而不能只有几个搜索的参数啊!!!!这说明一定要看报错说明啊，不然都不知道怎么死的</p><p>20.我今天被困在JpaRepository好累啊。首先，它的表建立不同于桂林项目，不需要再表字段中加上S_或者I_的前缀，我就这样被坑了好久好久好久！！！第二，JpaRepository没那么神奇，不是想某人说的，会自动根据你在接口写的方法名自动判断你要干什么，这已经是人工智能级别的东西了，别逗，它们都是已经封装好的方法，或者是按照一定的规则编写出来的方法名，这些都是固定的套路，所以不是你想写什么就能写什么的，或者自己写@Query注解的语句也行啊。第三，一定要传递Pageable这个参数，我发现好多地方都有用到啊。</p><p>21.听说jpa不能多表查询。。。。。我TM今天在干什么</p><p>22.想看这个页面问过我没？当出现这个问题时，问了同事说，要先跳出来再跳进去里面页面。然而别人不这么写。<br>看了好久，发现应该是这个问题，在index.js的router这个路由管理器中，{<br>path: ‘/devtools/personList/PersonEdit/:id’,<br>name: ‘Practice acx edit’,<br>component: PersonEdit,<br>meta: {<br>requireAuth: false<br>}<br>}<br>每一个路由都是这么写成的，在meta里面有一个requireAuth属性，默认是true的，我们需要将其改为false，就可以跳过。</p><p>23.在vue中的this.http.get(‘/admin/personInfo/‘ + this.$route.params.id).then(resp =&gt; {…}); 跳转中，有两个问题困住我近乎半天。<br>（1）从列表页怎么将id传给详情页呢？因为两个页面之间是路由跳转，所以无法依托Spring的Java后台来传递，所以要使用this.$route.params。是的，你讲这个this.$route.params在控制台console.log中打印出来，就能发现里面藏了你所要的id<br>（2）明明this.$route.params.id就是我要的id”700538815059591168”,为什么this.http.get(‘/admin/personInfo/‘, this.$route.params.id).then(resp =&gt; {…});这么写时，this.$route.params.id就变成了”0=700538815059591168”,别人这么写都好像没问题，就我卡住了，TM有病啊！！！心血来潮直接把逗号改为加号，结果就好了，TM你在逗我。</p><p>24.我想搜索三张表，第一张按照主键搜，第二三表用关联id搜索。第一张表用了Service.find(id),然而BaseService没有findOne（Filter）方法，我只能用findAll(Filter,Pageable);这个方法，然而Filter过滤没问题，甚至debug模式显示的sql语句都能搜索正确结果，用这个方法却出现了问题。答案就是，Pageable的问题。我估计Pageable的PageNumber和PageSize都为0，导致虽然有结果，但是无法显示。手动修改Pageable的这两个值即可。<br>用JPA吧，更直接</p><p>25.使用SpringBoot 中的 Jpa进行删除的时候 ，有三个点要记住，我TM混了半天多才弄懂。<br>–在JPA接口中定义删除方法名时，方法名和sql语句不同，sql语句是”delete from + 表名 + where + 条件”，而方法名是”delete + 实体名 + by + 条件筛选字段（实体类中定义的属性名） + 条件关键字（Equals、like、between等等）”，也就是说删除很不同，如果只是查找搜索的话，无需加上”实体名”和后面的”条件关键字”这两个，但是删除，就要了。<br>–在JPA接口中定义删除方法名时，一定不要忘记加上两个注解，那就是@Modifying 和 @Transactional这两个注解，原因我也不懂，我只知道你不加，TMD系统就会报错。<br>–在JPA接口中定义删除方法名时，删除的返回值是什么？我一开始是使用实体类来接收返回值的，问题是直接报错了，报了个错误说：Integer无法转换为PersonGfInfo（这个是我定义的实体类，也就是返回值），这说明什么？说明执行完delete语句后返回的值，就是一个数值，所以你在定义方法的时候，返回值要写成int型。</p><p>26.vue怎么使用多选框进行修改和删除呢？<br>1.先给每一个template的循环item添加一个多选框按钮，设置每一个框的value值为id或者其他不重复数值<br>2.让每一个多选框绑定一个全局的数据变量，如v-model=”ids”,<br>3.这样一旦选中一个多选框，ids这个全局数组变量就会自动添加或减少一个value值<br>4.var length = $(“input[type=’checkbox’]:checked”).length;通过这句话，可以获取选中多选框的数量。<br>5.如果想要进行删除操作，则需要向后台传递数组。那么注意，序列化ids的值，只是序列化，序列化后的结果，不是数组，而是表单，你在controller的接受参数只有一个(Long[] ids)，这里实质上是只有一个接收参数，这是数组不是表单，因此你需要在js中将ids转化为数组。怎么转化呢？<br>6.for循环，遍历ids，将每一个ids中的值逐个取出，在后面加上”，”逗号使之连接起来，如此形成一个数组，再向后台传递。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
